Definition Relation (U : Set) := U -> U -> Prop.
-----
Definition Reflexive (U : Set) (R : Relation U) : Prop := forall x : U, R x x.
-----
Definition Transitive (U : Set) (R : Relation U) : Prop :=\n  forall x y z : U, R x y -> R y z -> R x z.
-----
Definition Symmetric (U : Set) (R : Relation U) : Prop :=\n  forall x y : U, R x y -> R y x.
-----
Inductive Equivalence (U : Set) (R : Relation U) : Prop :=\n    Definition_of_equivalence :\n      Reflexive U R -> Symmetric U R -> Transitive U R -> Equivalence U R.
-----
Definition Negation (U : Set) (R : Relation U) : Relation U :=\n  fun x y : U => ~ R x y.
-----
Hint Unfold Negation.
-----
Theorem Sym_imp_NegSym :\n forall (U : Set) (R : Relation U),\n Symmetric U R -> Symmetric U (Negation U R).
-----
Theorem Sym_imp_NegSym : forall (U : Set) (R : Relation U), Symmetric U R -> Symmetric U (Negation U R).

*****

*****
forall (U : Set) (R : Relation U) (_ : Symmetric U R), Symmetric U (Negation U R)
+++++
unfold Symmetric in |- *.
-----
Theorem Sym_imp_NegSym : forall (U : Set) (R : Relation U), Symmetric U R -> Symmetric U (Negation U R).
unfold Symmetric in |- *.

*****

*****
forall (U : Set) (R : Relation U) (_ : forall (x y : U) (_ : R x y), R y x) (x y : U) (_ : Negation U R x y), Negation U R y x
+++++
unfold Negation in |- *.
-----
Theorem Sym_imp_NegSym : forall (U : Set) (R : Relation U), Symmetric U R -> Symmetric U (Negation U R).
unfold Symmetric in |- *.
unfold Negation in |- *.

*****

*****
forall (U : Set) (R : Relation U) (_ : forall (x y : U) (_ : R x y), R y x) (x y : U) (_ : not (R x y)), not (R y x)
+++++
intros U R H' x y H'0.
-----
Theorem Sym_imp_NegSym : forall (U : Set) (R : Relation U), Symmetric U R -> Symmetric U (Negation U R).
unfold Symmetric in |- *.
unfold Negation in |- *.
intros U R H' x y H'0.

*****
H'0 : not (R x y)
x,y : U
H' : forall (x y : U) (_ : R x y), R y x
R : Relation U
U : Set
*****
not (R y x)
+++++
red in |- *.
-----
Theorem Sym_imp_NegSym : forall (U : Set) (R : Relation U), Symmetric U R -> Symmetric U (Negation U R).
unfold Symmetric in |- *.
unfold Negation in |- *.
intros U R H' x y H'0.
red in |- *.

*****
H'0 : not (R x y)
x,y : U
H' : forall (x y : U) (_ : R x y), R y x
R : Relation U
U : Set
*****
forall _ : R y x, False
+++++
intro H'1.
-----
Theorem Sym_imp_NegSym : forall (U : Set) (R : Relation U), Symmetric U R -> Symmetric U (Negation U R).
unfold Symmetric in |- *.
unfold Negation in |- *.
intros U R H' x y H'0.
red in |- *.
intro H'1.

*****
H'1 : R y x
H'0 : not (R x y)
x,y : U
H' : forall (x y : U) (_ : R x y), R y x
R : Relation U
U : Set
*****
False
+++++
auto.
-----
Theorem Sym_imp_NegSym : forall (U : Set) (R : Relation U), Symmetric U R -> Symmetric U (Negation U R).
unfold Symmetric in |- *.
unfold Negation in |- *.
intros U R H' x y H'0.
red in |- *.
intro H'1.
auto.

*****

*****

+++++
Qed.
-----
Hint Resolve Sym_imp_NegSym.
-----
Definition Irreflexive (U : Set) (R : Relation U) : Prop :=\n  forall x : U, ~ R x x.
-----
Definition Separating (U : Set) (R : Relation U) : Prop :=\n  forall x y z : U, R x y -> R x z \/ R y z.
-----
Inductive Apartness (U : Set) (R : Relation U) : Prop :=\n    Definition_of_apartness :\n      Irreflexive U R -> Separating U R -> Apartness U R.
-----
Hint Unfold Reflexive Irreflexive Symmetric Transitive.
-----
Hint Resolve Definition_of_equivalence Definition_of_apartness.
-----
Parameter Point : Set.
-----
Parameter Line : Set.
-----
Parameter DiPt : Point -> Point -> Prop.
-----
Parameter DiLn : Line -> Line -> Prop.
-----
Parameter ConLn : Line -> Line -> Prop.
-----
Axiom apart_dipt : Apartness Point DiPt.
-----
Axiom apart_diln : Apartness Line DiLn.
-----
Axiom apart_con : Apartness Line ConLn.
-----
Hint Resolve apart_dipt apart_diln apart_con.
-----
Theorem Apart_imp_Sym :\n forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.

*****

*****
forall (U : Set) (R : Relation U) (_ : Apartness U R), Symmetric U R
+++++
Proof.
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.

*****

*****
forall (U : Set) (R : Relation U) (_ : Apartness U R), Symmetric U R
+++++
intros U R H'.
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.
intros U R H'.

*****
H' : Apartness U R
R : Relation U
U : Set
*****
Symmetric U R
+++++
elim H'.
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.
intros U R H'.
elim H'.

*****
H' : Apartness U R
R : Relation U
U : Set
*****
forall (_ : Irreflexive U R) (_ : Separating U R), Symmetric U R
+++++
intros H'0 H'1.
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.
intros U R H'.
elim H'.
intros H'0 H'1.

*****
H'1 : Separating U R
H'0 : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
Symmetric U R
+++++
red in |- *.
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.
intros U R H'.
elim H'.
intros H'0 H'1.
red in |- *.

*****
H'1 : Separating U R
H'0 : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
forall (x y : U) (_ : R x y), R y x
+++++
intros x y H'2.
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.
intros U R H'.
elim H'.
intros H'0 H'1.
red in |- *.
intros x y H'2.

*****
H'2 : R x y
x,y : U
H'1 : Separating U R
H'0 : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
R y x
+++++
red in H'1.
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.
intros U R H'.
elim H'.
intros H'0 H'1.
red in |- *.
intros x y H'2.
red in H'1.

*****
H'2 : R x y
x,y : U
H'1 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H'0 : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
R y x
+++++
elim (H'1 x y x).
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.
intros U R H'.
elim H'.
intros H'0 H'1.
red in |- *.
intros x y H'2.
red in H'1.
elim (H'1 x y x).

*****
H'2 : R x y
x,y : U
H'1 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H'0 : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
forall _ : R x x, R y x
+++++
trivial.
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.
intros U R H'.
elim H'.
intros H'0 H'1.
red in |- *.
intros x y H'2.
red in H'1.
elim (H'1 x y x).
trivial.

*****
H'2 : R x y
x,y : U
H'1 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H'0 : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
forall _ : R x x, R y x
+++++
intro H'3.
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.
intros U R H'.
elim H'.
intros H'0 H'1.
red in |- *.
intros x y H'2.
red in H'1.
elim (H'1 x y x).
trivial.
intro H'3.

*****
H'3 : R x x
H'2 : R x y
x,y : U
H'1 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H'0 : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
R y x
+++++
elim (H'0 x).
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.
intros U R H'.
elim H'.
intros H'0 H'1.
red in |- *.
intros x y H'2.
red in H'1.
elim (H'1 x y x).
trivial.
intro H'3.
elim (H'0 x).

*****
H'3 : R x x
H'2 : R x y
x,y : U
H'1 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H'0 : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
R x x
+++++
trivial.
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.
intros U R H'.
elim H'.
intros H'0 H'1.
red in |- *.
intros x y H'2.
red in H'1.
elim (H'1 x y x).

*****
H'2 : R x y
x,y : U
H'1 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H'0 : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
forall _ : R y x, R y x
+++++
trivial.
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.
intros U R H'.
elim H'.
intros H'0 H'1.
red in |- *.
intros x y H'2.
red in H'1.
elim (H'1 x y x).

*****
H'2 : R x y
x,y : U
H'1 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H'0 : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
R x y
+++++
trivial.
-----
Theorem Apart_imp_Sym : forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.
Proof.
intros U R H'.
elim H'.
intros H'0 H'1.
red in |- *.
intros x y H'2.
red in H'1.
elim (H'1 x y x).

*****

*****

+++++
Qed.
-----
Hint Resolve Apart_imp_Sym.
-----
Theorem sym_DiPt : forall x y : Point, DiPt x y -> DiPt y x.
-----
Theorem sym_DiPt : forall x y : Point, DiPt x y -> DiPt y x.

*****

*****
forall (x y : Point) (_ : DiPt x y), DiPt y x
+++++
Proof.
-----
Theorem sym_DiPt : forall x y : Point, DiPt x y -> DiPt y x.
Proof.

*****

*****
forall (x y : Point) (_ : DiPt x y), DiPt y x
+++++
intros x y H'.
-----
Theorem sym_DiPt : forall x y : Point, DiPt x y -> DiPt y x.
Proof.
intros x y H'.

*****
H' : DiPt x y
x,y : Point
*****
DiPt y x
+++++
cut (Symmetric Point DiPt).
-----
Theorem sym_DiPt : forall x y : Point, DiPt x y -> DiPt y x.
Proof.
intros x y H'.
cut (Symmetric Point DiPt).

*****
H' : DiPt x y
x,y : Point
*****
forall _ : Symmetric Point DiPt, DiPt y x
+++++
auto.
-----
Theorem sym_DiPt : forall x y : Point, DiPt x y -> DiPt y x.
Proof.
intros x y H'.
cut (Symmetric Point DiPt).

*****
H' : DiPt x y
x,y : Point
*****
Symmetric Point DiPt
+++++
auto.
-----
Theorem sym_DiPt : forall x y : Point, DiPt x y -> DiPt y x.
Proof.
intros x y H'.
cut (Symmetric Point DiPt).

*****

*****

+++++
Qed.
-----
Theorem sym_DiLn : forall x y : Line, DiLn x y -> DiLn y x.
-----
Theorem sym_DiLn : forall x y : Line, DiLn x y -> DiLn y x.

*****

*****
forall (x y : Line) (_ : DiLn x y), DiLn y x
+++++
Proof.
-----
Theorem sym_DiLn : forall x y : Line, DiLn x y -> DiLn y x.
Proof.

*****

*****
forall (x y : Line) (_ : DiLn x y), DiLn y x
+++++
intros x y H'.
-----
Theorem sym_DiLn : forall x y : Line, DiLn x y -> DiLn y x.
Proof.
intros x y H'.

*****
H' : DiLn x y
x,y : Line
*****
DiLn y x
+++++
cut (Symmetric Line DiLn).
-----
Theorem sym_DiLn : forall x y : Line, DiLn x y -> DiLn y x.
Proof.
intros x y H'.
cut (Symmetric Line DiLn).

*****
H' : DiLn x y
x,y : Line
*****
forall _ : Symmetric Line DiLn, DiLn y x
+++++
auto.
-----
Theorem sym_DiLn : forall x y : Line, DiLn x y -> DiLn y x.
Proof.
intros x y H'.
cut (Symmetric Line DiLn).

*****
H' : DiLn x y
x,y : Line
*****
Symmetric Line DiLn
+++++
auto.
-----
Theorem sym_DiLn : forall x y : Line, DiLn x y -> DiLn y x.
Proof.
intros x y H'.
cut (Symmetric Line DiLn).

*****

*****

+++++
Qed.
-----
Theorem sym_ConLn : forall x y : Line, ConLn x y -> ConLn y x.
-----
Theorem sym_ConLn : forall x y : Line, ConLn x y -> ConLn y x.

*****

*****
forall (x y : Line) (_ : ConLn x y), ConLn y x
+++++
Proof.
-----
Theorem sym_ConLn : forall x y : Line, ConLn x y -> ConLn y x.
Proof.

*****

*****
forall (x y : Line) (_ : ConLn x y), ConLn y x
+++++
intros x y H'.
-----
Theorem sym_ConLn : forall x y : Line, ConLn x y -> ConLn y x.
Proof.
intros x y H'.

*****
H' : ConLn x y
x,y : Line
*****
ConLn y x
+++++
cut (Symmetric Line ConLn).
-----
Theorem sym_ConLn : forall x y : Line, ConLn x y -> ConLn y x.
Proof.
intros x y H'.
cut (Symmetric Line ConLn).

*****
H' : ConLn x y
x,y : Line
*****
forall _ : Symmetric Line ConLn, ConLn y x
+++++
auto.
-----
Theorem sym_ConLn : forall x y : Line, ConLn x y -> ConLn y x.
Proof.
intros x y H'.
cut (Symmetric Line ConLn).

*****
H' : ConLn x y
x,y : Line
*****
Symmetric Line ConLn
+++++
auto.
-----
Theorem sym_ConLn : forall x y : Line, ConLn x y -> ConLn y x.
Proof.
intros x y H'.
cut (Symmetric Line ConLn).

*****

*****

+++++
Qed.
-----
Hint Immediate sym_DiPt sym_DiLn sym_ConLn.
-----
Theorem Neg_apart_equiv :\n forall (U : Set) (R : Relation U),\n Apartness U R -> Equivalence U (Negation U R).
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).

*****

*****
forall (U : Set) (R : Relation U) (_ : Apartness U R), Equivalence U (Negation U R)
+++++
Proof.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.

*****

*****
forall (U : Set) (R : Relation U) (_ : Apartness U R), Equivalence U (Negation U R)
+++++
intros U R H'.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.

*****
H' : Apartness U R
R : Relation U
U : Set
*****
Equivalence U (Negation U R)
+++++
elim H'.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.

*****
H' : Apartness U R
R : Relation U
U : Set
*****
forall (_ : Irreflexive U R) (_ : Separating U R), Equivalence U (Negation U R)
+++++
constructor 1.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.

*****
H0 : Separating U R
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
Reflexive U (Negation U R)
+++++
auto.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.

*****
H0 : Separating U R
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
Symmetric U (Negation U R)
+++++
auto.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.

*****
H0 : Separating U R
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
Transitive U (Negation U R)
+++++
auto.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.
auto.

*****
H0 : Separating U R
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
Transitive U (Negation U R)
+++++
unfold Transitive in |- *.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.
auto.
unfold Transitive in |- *.

*****
H0 : Separating U R
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
forall (x y z : U) (_ : Negation U R x y) (_ : Negation U R y z), Negation U R x z
+++++
unfold Negation in |- *.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.
auto.
unfold Transitive in |- *.
unfold Negation in |- *.

*****
H0 : Separating U R
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
forall (x y z : U) (_ : not (R x y)) (_ : not (R y z)), not (R x z)
+++++
intros x y z H'2 H'3.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.
auto.
unfold Transitive in |- *.
unfold Negation in |- *.
intros x y z H'2 H'3.

*****
H'3 : not (R y z)
H'2 : not (R x y)
x,y,z : U
H0 : Separating U R
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
not (R x z)
+++++
red in |- *.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.
auto.
unfold Transitive in |- *.
unfold Negation in |- *.
intros x y z H'2 H'3.
red in |- *.

*****
H'3 : not (R y z)
H'2 : not (R x y)
x,y,z : U
H0 : Separating U R
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
forall _ : R x z, False
+++++
intro H'4.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.
auto.
unfold Transitive in |- *.
unfold Negation in |- *.
intros x y z H'2 H'3.
red in |- *.
intro H'4.

*****
H'4 : R x z
H'3 : not (R y z)
H'2 : not (R x y)
x,y,z : U
H0 : Separating U R
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
False
+++++
red in H0.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.
auto.
unfold Transitive in |- *.
unfold Negation in |- *.
intros x y z H'2 H'3.
red in |- *.
intro H'4.
red in H0.

*****
H'4 : R x z
H'3 : not (R y z)
H'2 : not (R x y)
x,y,z : U
H0 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
False
+++++
elim (H0 x z y).
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.
auto.
unfold Transitive in |- *.
unfold Negation in |- *.
intros x y z H'2 H'3.
red in |- *.
intro H'4.
red in H0.
elim (H0 x z y).

*****
H'4 : R x z
H'3 : not (R y z)
H'2 : not (R x y)
x,y,z : U
H0 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
forall _ : R x y, False
+++++
auto.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.
auto.
unfold Transitive in |- *.
unfold Negation in |- *.
intros x y z H'2 H'3.
red in |- *.
intro H'4.
red in H0.
elim (H0 x z y).

*****
H'4 : R x z
H'3 : not (R y z)
H'2 : not (R x y)
x,y,z : U
H0 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
forall _ : R z y, False
+++++
auto.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.
auto.
unfold Transitive in |- *.
unfold Negation in |- *.
intros x y z H'2 H'3.
red in |- *.
intro H'4.
red in H0.
elim (H0 x z y).
auto.

*****
H'4 : R x z
H'3 : not (R y z)
H'2 : not (R x y)
x,y,z : U
H0 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
forall _ : R z y, False
+++++
cut (Symmetric U R).
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.
auto.
unfold Transitive in |- *.
unfold Negation in |- *.
intros x y z H'2 H'3.
red in |- *.
intro H'4.
red in H0.
elim (H0 x z y).
auto.
cut (Symmetric U R).

*****
H'4 : R x z
H'3 : not (R y z)
H'2 : not (R x y)
x,y,z : U
H0 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
forall (_ : Symmetric U R) (_ : R z y), False
+++++
auto.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.
auto.
unfold Transitive in |- *.
unfold Negation in |- *.
intros x y z H'2 H'3.
red in |- *.
intro H'4.
red in H0.
elim (H0 x z y).
auto.
cut (Symmetric U R).

*****
H'4 : R x z
H'3 : not (R y z)
H'2 : not (R x y)
x,y,z : U
H0 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
Symmetric U R
+++++
auto.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.
auto.
unfold Transitive in |- *.
unfold Negation in |- *.
intros x y z H'2 H'3.
red in |- *.
intro H'4.
red in H0.
elim (H0 x z y).

*****
H'4 : R x z
H'3 : not (R y z)
H'2 : not (R x y)
x,y,z : U
H0 : forall (x y z : U) (_ : R x y), or (R x z) (R y z)
H : Irreflexive U R
H' : Apartness U R
R : Relation U
U : Set
*****
R x z
+++++
auto.
-----
Theorem Neg_apart_equiv : forall (U : Set) (R : Relation U), Apartness U R -> Equivalence U (Negation U R).
Proof.
intros U R H'.
elim H'.
constructor 1.

*****

*****

+++++
Qed.
-----
Hint Resolve Neg_apart_equiv.
-----
Definition EqPt := Negation Point DiPt.
-----
Definition EqLn := Negation Line DiLn.
-----
Definition Par := Negation Line ConLn.
-----
Theorem equiv_EqPt : Equivalence Point EqPt.
-----
Theorem equiv_EqPt : Equivalence Point EqPt.

*****

*****
Equivalence Point EqPt
+++++
Proof.
-----
Theorem equiv_EqPt : Equivalence Point EqPt.
Proof.

*****

*****
Equivalence Point EqPt
+++++
unfold EqPt in |- *.
-----
Theorem equiv_EqPt : Equivalence Point EqPt.
Proof.
unfold EqPt in |- *.

*****

*****
Equivalence Point (Negation Point DiPt)
+++++
auto.
-----
Theorem equiv_EqPt : Equivalence Point EqPt.
Proof.
unfold EqPt in |- *.
auto.

*****

*****

+++++
Qed.
-----
Hint Resolve equiv_EqPt.
-----
Theorem equiv_EqLn : Equivalence Line EqLn.
-----
Theorem equiv_EqLn : Equivalence Line EqLn.

*****

*****
Equivalence Line EqLn
+++++
Proof.
-----
Theorem equiv_EqLn : Equivalence Line EqLn.
Proof.

*****

*****
Equivalence Line EqLn
+++++
unfold EqLn in |- *.
-----
Theorem equiv_EqLn : Equivalence Line EqLn.
Proof.
unfold EqLn in |- *.

*****

*****
Equivalence Line (Negation Line DiLn)
+++++
auto.
-----
Theorem equiv_EqLn : Equivalence Line EqLn.
Proof.
unfold EqLn in |- *.
auto.

*****

*****

+++++
Qed.
-----
Hint Resolve equiv_EqLn.
-----
Theorem equiv_Par : Equivalence Line Par.
-----
Theorem equiv_Par : Equivalence Line Par.

*****

*****
Equivalence Line Par
+++++
Proof.
-----
Theorem equiv_Par : Equivalence Line Par.
Proof.

*****

*****
Equivalence Line Par
+++++
unfold Par in |- *.
-----
Theorem equiv_Par : Equivalence Line Par.
Proof.
unfold Par in |- *.

*****

*****
Equivalence Line (Negation Line ConLn)
+++++
auto.
-----
Theorem equiv_Par : Equivalence Line Par.
Proof.
unfold Par in |- *.
auto.

*****

*****

+++++
Qed.
-----
Hint Resolve equiv_Par.
-----
Theorem sym_EqPt : forall x y : Point, EqPt x y -> EqPt y x.
-----
Theorem sym_EqPt : forall x y : Point, EqPt x y -> EqPt y x.

*****

*****
forall (x y : Point) (_ : EqPt x y), EqPt y x
+++++
Proof.
-----
Theorem sym_EqPt : forall x y : Point, EqPt x y -> EqPt y x.
Proof.

*****

*****
forall (x y : Point) (_ : EqPt x y), EqPt y x
+++++
intros x y H'.
-----
Theorem sym_EqPt : forall x y : Point, EqPt x y -> EqPt y x.
Proof.
intros x y H'.

*****
H' : EqPt x y
x,y : Point
*****
EqPt y x
+++++
cut (Symmetric Point EqPt).
-----
Theorem sym_EqPt : forall x y : Point, EqPt x y -> EqPt y x.
Proof.
intros x y H'.
cut (Symmetric Point EqPt).

*****
H' : EqPt x y
x,y : Point
*****
forall _ : Symmetric Point EqPt, EqPt y x
+++++
auto.
-----
Theorem sym_EqPt : forall x y : Point, EqPt x y -> EqPt y x.
Proof.
intros x y H'.
cut (Symmetric Point EqPt).

*****
H' : EqPt x y
x,y : Point
*****
Symmetric Point EqPt
+++++
auto.
-----
Theorem sym_EqPt : forall x y : Point, EqPt x y -> EqPt y x.
Proof.
intros x y H'.
cut (Symmetric Point EqPt).
auto.

*****
H' : EqPt x y
x,y : Point
*****
Symmetric Point EqPt
+++++
unfold EqPt at 1 in |- *.
-----
Theorem sym_EqPt : forall x y : Point, EqPt x y -> EqPt y x.
Proof.
intros x y H'.
cut (Symmetric Point EqPt).
auto.
unfold EqPt at 1 in |- *.

*****
H' : EqPt x y
x,y : Point
*****
Symmetric Point (Negation Point DiPt)
+++++
auto.
-----
Theorem sym_EqPt : forall x y : Point, EqPt x y -> EqPt y x.
Proof.
intros x y H'.
cut (Symmetric Point EqPt).

*****

*****

+++++
Qed.
-----
Theorem sym_EqLn : forall x y : Line, EqLn x y -> EqLn y x.
-----
Theorem sym_EqLn : forall x y : Line, EqLn x y -> EqLn y x.

*****

*****
forall (x y : Line) (_ : EqLn x y), EqLn y x
+++++
Proof.
-----
Theorem sym_EqLn : forall x y : Line, EqLn x y -> EqLn y x.
Proof.

*****

*****
forall (x y : Line) (_ : EqLn x y), EqLn y x
+++++
intros x y H'.
-----
Theorem sym_EqLn : forall x y : Line, EqLn x y -> EqLn y x.
Proof.
intros x y H'.

*****
H' : EqLn x y
x,y : Line
*****
EqLn y x
+++++
cut (Symmetric Line EqLn).
-----
Theorem sym_EqLn : forall x y : Line, EqLn x y -> EqLn y x.
Proof.
intros x y H'.
cut (Symmetric Line EqLn).

*****
H' : EqLn x y
x,y : Line
*****
forall _ : Symmetric Line EqLn, EqLn y x
+++++
auto.
-----
Theorem sym_EqLn : forall x y : Line, EqLn x y -> EqLn y x.
Proof.
intros x y H'.
cut (Symmetric Line EqLn).

*****
H' : EqLn x y
x,y : Line
*****
Symmetric Line EqLn
+++++
auto.
-----
Theorem sym_EqLn : forall x y : Line, EqLn x y -> EqLn y x.
Proof.
intros x y H'.
cut (Symmetric Line EqLn).
auto.

*****
H' : EqLn x y
x,y : Line
*****
Symmetric Line EqLn
+++++
unfold EqLn at 1 in |- *.
-----
Theorem sym_EqLn : forall x y : Line, EqLn x y -> EqLn y x.
Proof.
intros x y H'.
cut (Symmetric Line EqLn).
auto.
unfold EqLn at 1 in |- *.

*****
H' : EqLn x y
x,y : Line
*****
Symmetric Line (Negation Line DiLn)
+++++
auto.
-----
Theorem sym_EqLn : forall x y : Line, EqLn x y -> EqLn y x.
Proof.
intros x y H'.
cut (Symmetric Line EqLn).

*****

*****

+++++
Qed.
-----
Theorem sym_Par : forall x y : Line, Par x y -> Par y x.
-----
Theorem sym_Par : forall x y : Line, Par x y -> Par y x.

*****

*****
forall (x y : Line) (_ : Par x y), Par y x
+++++
Proof.
-----
Theorem sym_Par : forall x y : Line, Par x y -> Par y x.
Proof.

*****

*****
forall (x y : Line) (_ : Par x y), Par y x
+++++
intros x y H'.
-----
Theorem sym_Par : forall x y : Line, Par x y -> Par y x.
Proof.
intros x y H'.

*****
H' : Par x y
x,y : Line
*****
Par y x
+++++
cut (Symmetric Line Par).
-----
Theorem sym_Par : forall x y : Line, Par x y -> Par y x.
Proof.
intros x y H'.
cut (Symmetric Line Par).

*****
H' : Par x y
x,y : Line
*****
forall _ : Symmetric Line Par, Par y x
+++++
auto.
-----
Theorem sym_Par : forall x y : Line, Par x y -> Par y x.
Proof.
intros x y H'.
cut (Symmetric Line Par).

*****
H' : Par x y
x,y : Line
*****
Symmetric Line Par
+++++
auto.
-----
Theorem sym_Par : forall x y : Line, Par x y -> Par y x.
Proof.
intros x y H'.
cut (Symmetric Line Par).
auto.

*****
H' : Par x y
x,y : Line
*****
Symmetric Line Par
+++++
unfold Par at 1 in |- *.
-----
Theorem sym_Par : forall x y : Line, Par x y -> Par y x.
Proof.
intros x y H'.
cut (Symmetric Line Par).
auto.
unfold Par at 1 in |- *.

*****
H' : Par x y
x,y : Line
*****
Symmetric Line (Negation Line ConLn)
+++++
auto.
-----
Theorem sym_Par : forall x y : Line, Par x y -> Par y x.
Proof.
intros x y H'.
cut (Symmetric Line Par).

*****

*****

+++++
Qed.
-----
Hint Immediate sym_EqPt sym_EqLn sym_Par.
-----
Parameter Apart : Point -> Line -> Prop.
-----
Definition Incident (a : Point) (l : Line) := ~ Apart a l.
-----
Record Segment : Set := Seg\n  {origin : Point; extremity : Point; Seg_cond : DiPt origin extremity}.
-----
Record Twolines : Set := Twol\n  {line1 : Line; line2 : Line; Twol_cond : ConLn line1 line2}.
-----
Axiom\n  line :\n    forall x : Segment,\n    {l : Line | Incident (origin x) l /\ Incident (extremity x) l}.
-----
Axiom\n  point :\n    forall x : Twolines,\n    {a : Point | Incident a (line1 x) /\ Incident a (line2 x)}.
-----
Definition ln : Segment -> Line.
-----
Definition ln : Segment -> Line.

*****

*****
forall _ : Segment, Line
+++++
Proof.
-----
Definition ln : Segment -> Line.
Proof.

*****

*****
forall _ : Segment, Line
+++++
intro x.
-----
Definition ln : Segment -> Line.
Proof.
intro x.

*****
x : Segment
*****
Line
+++++
elim (line x).
-----
Definition ln : Segment -> Line.
Proof.
intro x.
elim (line x).

*****
x : Segment
*****
forall (x0 : Line) (_ : and (Incident (origin x) x0) (Incident (extremity x) x0)), Line
+++++
intros x0 H'.
-----
Definition ln : Segment -> Line.
Proof.
intro x.
elim (line x).
intros x0 H'.

*****
H' : and (Incident (origin x) x0) (Incident (extremity x) x0)
x0 : Line
x : Segment
*****
Line
+++++
exact x0.
-----
Definition ln : Segment -> Line.
Proof.
intro x.
elim (line x).
intros x0 H'.
exact x0.

*****

*****

+++++
Defined.
-----
Definition pt : Twolines -> Point.
-----
Definition pt : Twolines -> Point.

*****

*****
forall _ : Twolines, Point
+++++
Proof.
-----
Definition pt : Twolines -> Point.
Proof.

*****

*****
forall _ : Twolines, Point
+++++
intro x.
-----
Definition pt : Twolines -> Point.
Proof.
intro x.

*****
x : Twolines
*****
Point
+++++
elim (point x).
-----
Definition pt : Twolines -> Point.
Proof.
intro x.
elim (point x).

*****
x : Twolines
*****
forall (x0 : Point) (_ : and (Incident x0 (line1 x)) (Incident x0 (line2 x))), Point
+++++
intros x0 H'.
-----
Definition pt : Twolines -> Point.
Proof.
intro x.
elim (point x).
intros x0 H'.

*****
H' : and (Incident x0 (line1 x)) (Incident x0 (line2 x))
x0 : Point
x : Twolines
*****
Point
+++++
exact x0.
-----
Definition pt : Twolines -> Point.
Proof.
intro x.
elim (point x).
intros x0 H'.
exact x0.

*****

*****

+++++
Defined.
-----
Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).
-----
Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).

*****

*****
forall x : Segment, Incident (origin x) (ln x)
+++++
Proof.
-----
Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).
Proof.

*****

*****
forall x : Segment, Incident (origin x) (ln x)
+++++
intro x.
-----
Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).
Proof.
intro x.

*****
x : Segment
*****
Incident (origin x) (ln x)
+++++
elim x.
-----
Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).
Proof.
intro x.
elim x.

*****
x : Segment
*****
forall (origin0 extremity : Point) (Seg_cond : DiPt origin0 extremity), Incident (origin {| origin := origin0; extremity := extremity; Seg_cond := Seg_cond |}) (ln {| origin := origin0; extremity := extremity; Seg_cond := Seg_cond |})
+++++
intros a b d.
-----
Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).
Proof.
intro x.
elim x.
intros a b d.

*****
d : DiPt a b
a,b : Point
x : Segment
*****
Incident (origin {| origin := a; extremity := b; Seg_cond := d |}) (ln {| origin := a; extremity := b; Seg_cond := d |})
+++++
unfold ln in |- *.
-----
Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).
Proof.
intro x.
elim x.
intros a b d.
unfold ln in |- *.

*****
d : DiPt a b
a,b : Point
x : Segment
*****
Incident (origin {| origin := a; extremity := b; Seg_cond := d |}) (sig_rec (fun _ : sig (fun l : Line => and (Incident (origin {| origin := a; extremity := b; Seg_cond := d |}) l) (Incident (extremity {| origin := a; extremity := b; Seg_cond := d |}) l)) => Line) (fun (x0 : Line) (_ : and (Incident (origin {| origin := a; extremity := b; Seg_cond := d |}) x0) (Incident (extremity {| origin := a; extremity := b; Seg_cond := d |}) x0)) => x0) (line {| origin := a; extremity := b; Seg_cond := d |}))
+++++
simpl in |- *.
-----
Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).
Proof.
intro x.
elim x.
intros a b d.
unfold ln in |- *.
simpl in |- *.

*****
d : DiPt a b
a,b : Point
x : Segment
*****
Incident a (sig_rec (fun _ : sig (fun l : Line => and (Incident a l) (Incident b l)) => Line) (fun (x0 : Line) (_ : and (Incident a x0) (Incident b x0)) => x0) (line {| origin := a; extremity := b; Seg_cond := d |}))
+++++
elim (line (Seg a b d)).
-----
Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).
Proof.
intro x.
elim x.
intros a b d.
unfold ln in |- *.
simpl in |- *.
elim (line (Seg a b d)).

*****
d : DiPt a b
a,b : Point
x : Segment
*****
forall (x : Line) (p : and (Incident (origin {| origin := a; extremity := b; Seg_cond := d |}) x) (Incident (extremity {| origin := a; extremity := b; Seg_cond := d |}) x)), Incident a (sig_rec (fun _ : sig (fun l : Line => and (Incident a l) (Incident b l)) => Line) (fun (x0 : Line) (_ : and (Incident a x0) (Incident b x0)) => x0) (exist (fun l : Line => and (Incident (origin {| origin := a; extremity := b; Seg_cond := d |}) l) (Incident (extremity {| origin := a; extremity := b; Seg_cond := d |}) l)) x p))
+++++
simpl in |- *.
-----
Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).
Proof.
intro x.
elim x.
intros a b d.
unfold ln in |- *.
simpl in |- *.
elim (line (Seg a b d)).
simpl in |- *.

*****
d : DiPt a b
a,b : Point
x : Segment
*****
forall (x : Line) (_ : and (Incident a x) (Incident b x)), Incident a x
+++++
tauto.
-----
Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).
Proof.
intro x.
elim x.
intros a b d.
unfold ln in |- *.
simpl in |- *.
elim (line (Seg a b d)).
simpl in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).
-----
Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).

*****

*****
forall x : Segment, Incident (extremity x) (ln x)
+++++
Proof.
-----
Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).
Proof.

*****

*****
forall x : Segment, Incident (extremity x) (ln x)
+++++
intro x.
-----
Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).
Proof.
intro x.

*****
x : Segment
*****
Incident (extremity x) (ln x)
+++++
elim x.
-----
Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).
Proof.
intro x.
elim x.

*****
x : Segment
*****
forall (origin extremity0 : Point) (Seg_cond : DiPt origin extremity0), Incident (extremity {| origin := origin; extremity := extremity0; Seg_cond := Seg_cond |}) (ln {| origin := origin; extremity := extremity0; Seg_cond := Seg_cond |})
+++++
intros a b d.
-----
Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).
Proof.
intro x.
elim x.
intros a b d.

*****
d : DiPt a b
a,b : Point
x : Segment
*****
Incident (extremity {| origin := a; extremity := b; Seg_cond := d |}) (ln {| origin := a; extremity := b; Seg_cond := d |})
+++++
unfold ln in |- *.
-----
Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).
Proof.
intro x.
elim x.
intros a b d.
unfold ln in |- *.

*****
d : DiPt a b
a,b : Point
x : Segment
*****
Incident (extremity {| origin := a; extremity := b; Seg_cond := d |}) (sig_rec (fun _ : sig (fun l : Line => and (Incident (origin {| origin := a; extremity := b; Seg_cond := d |}) l) (Incident (extremity {| origin := a; extremity := b; Seg_cond := d |}) l)) => Line) (fun (x0 : Line) (_ : and (Incident (origin {| origin := a; extremity := b; Seg_cond := d |}) x0) (Incident (extremity {| origin := a; extremity := b; Seg_cond := d |}) x0)) => x0) (line {| origin := a; extremity := b; Seg_cond := d |}))
+++++
simpl in |- *.
-----
Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).
Proof.
intro x.
elim x.
intros a b d.
unfold ln in |- *.
simpl in |- *.

*****
d : DiPt a b
a,b : Point
x : Segment
*****
Incident b (sig_rec (fun _ : sig (fun l : Line => and (Incident a l) (Incident b l)) => Line) (fun (x0 : Line) (_ : and (Incident a x0) (Incident b x0)) => x0) (line {| origin := a; extremity := b; Seg_cond := d |}))
+++++
elim (line (Seg a b d)).
-----
Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).
Proof.
intro x.
elim x.
intros a b d.
unfold ln in |- *.
simpl in |- *.
elim (line (Seg a b d)).

*****
d : DiPt a b
a,b : Point
x : Segment
*****
forall (x : Line) (p : and (Incident (origin {| origin := a; extremity := b; Seg_cond := d |}) x) (Incident (extremity {| origin := a; extremity := b; Seg_cond := d |}) x)), Incident b (sig_rec (fun _ : sig (fun l : Line => and (Incident a l) (Incident b l)) => Line) (fun (x0 : Line) (_ : and (Incident a x0) (Incident b x0)) => x0) (exist (fun l : Line => and (Incident (origin {| origin := a; extremity := b; Seg_cond := d |}) l) (Incident (extremity {| origin := a; extremity := b; Seg_cond := d |}) l)) x p))
+++++
simpl in |- *.
-----
Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).
Proof.
intro x.
elim x.
intros a b d.
unfold ln in |- *.
simpl in |- *.
elim (line (Seg a b d)).
simpl in |- *.

*****
d : DiPt a b
a,b : Point
x : Segment
*****
forall (x : Line) (_ : and (Incident a x) (Incident b x)), Incident b x
+++++
tauto.
-----
Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).
Proof.
intro x.
elim x.
intros a b d.
unfold ln in |- *.
simpl in |- *.
elim (line (Seg a b d)).
simpl in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).
-----
Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).

*****

*****
forall x : Twolines, Incident (pt x) (line1 x)
+++++
Proof.
-----
Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).
Proof.

*****

*****
forall x : Twolines, Incident (pt x) (line1 x)
+++++
intro x.
-----
Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).
Proof.
intro x.

*****
x : Twolines
*****
Incident (pt x) (line1 x)
+++++
elim x.
-----
Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).
Proof.
intro x.
elim x.

*****
x : Twolines
*****
forall (line2 line3 : Line) (Twol_cond : ConLn line2 line3), Incident (pt {| line1 := line2; line2 := line3; Twol_cond := Twol_cond |}) (line1 {| line1 := line2; line2 := line3; Twol_cond := Twol_cond |})
+++++
intros a b d.
-----
Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).
Proof.
intro x.
elim x.
intros a b d.

*****
d : ConLn a b
a,b : Line
x : Twolines
*****
Incident (pt {| line1 := a; line2 := b; Twol_cond := d |}) (line1 {| line1 := a; line2 := b; Twol_cond := d |})
+++++
unfold pt in |- *.
-----
Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).
Proof.
intro x.
elim x.
intros a b d.
unfold pt in |- *.

*****
d : ConLn a b
a,b : Line
x : Twolines
*****
Incident (sig_rec (fun _ : sig (fun a0 : Point => and (Incident a0 (line1 {| line1 := a; line2 := b; Twol_cond := d |})) (Incident a0 (line2 {| line1 := a; line2 := b; Twol_cond := d |}))) => Point) (fun (x0 : Point) (_ : and (Incident x0 (line1 {| line1 := a; line2 := b; Twol_cond := d |})) (Incident x0 (line2 {| line1 := a; line2 := b; Twol_cond := d |}))) => x0) (point {| line1 := a; line2 := b; Twol_cond := d |})) (line1 {| line1 := a; line2 := b; Twol_cond := d |})
+++++
simpl in |- *.
-----
Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).
Proof.
intro x.
elim x.
intros a b d.
unfold pt in |- *.
simpl in |- *.

*****
d : ConLn a b
a,b : Line
x : Twolines
*****
Incident (sig_rec (fun _ : sig (fun a0 : Point => and (Incident a0 a) (Incident a0 b)) => Point) (fun (x0 : Point) (_ : and (Incident x0 a) (Incident x0 b)) => x0) (point {| line1 := a; line2 := b; Twol_cond := d |})) a
+++++
elim (point (Twol a b d)).
-----
Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).
Proof.
intro x.
elim x.
intros a b d.
unfold pt in |- *.
simpl in |- *.
elim (point (Twol a b d)).

*****
d : ConLn a b
a,b : Line
x : Twolines
*****
forall (x : Point) (p : and (Incident x (line1 {| line1 := a; line2 := b; Twol_cond := d |})) (Incident x (line2 {| line1 := a; line2 := b; Twol_cond := d |}))), Incident (sig_rec (fun _ : sig (fun a0 : Point => and (Incident a0 a) (Incident a0 b)) => Point) (fun (x0 : Point) (_ : and (Incident x0 a) (Incident x0 b)) => x0) (exist (fun a0 : Point => and (Incident a0 (line1 {| line1 := a; line2 := b; Twol_cond := d |})) (Incident a0 (line2 {| line1 := a; line2 := b; Twol_cond := d |}))) x p)) a
+++++
simpl in |- *.
-----
Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).
Proof.
intro x.
elim x.
intros a b d.
unfold pt in |- *.
simpl in |- *.
elim (point (Twol a b d)).
simpl in |- *.

*****
d : ConLn a b
a,b : Line
x : Twolines
*****
forall (x : Point) (_ : and (Incident x a) (Incident x b)), Incident x a
+++++
tauto.
-----
Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).
Proof.
intro x.
elim x.
intros a b d.
unfold pt in |- *.
simpl in |- *.
elim (point (Twol a b d)).
simpl in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).
-----
Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).

*****

*****
forall x : Twolines, Incident (pt x) (line2 x)
+++++
Proof.
-----
Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).
Proof.

*****

*****
forall x : Twolines, Incident (pt x) (line2 x)
+++++
intro x.
-----
Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).
Proof.
intro x.

*****
x : Twolines
*****
Incident (pt x) (line2 x)
+++++
elim x.
-----
Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).
Proof.
intro x.
elim x.

*****
x : Twolines
*****
forall (line1 line3 : Line) (Twol_cond : ConLn line1 line3), Incident (pt {| line1 := line1; line2 := line3; Twol_cond := Twol_cond |}) (line2 {| line1 := line1; line2 := line3; Twol_cond := Twol_cond |})
+++++
intros a b d.
-----
Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).
Proof.
intro x.
elim x.
intros a b d.

*****
d : ConLn a b
a,b : Line
x : Twolines
*****
Incident (pt {| line1 := a; line2 := b; Twol_cond := d |}) (line2 {| line1 := a; line2 := b; Twol_cond := d |})
+++++
unfold pt in |- *.
-----
Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).
Proof.
intro x.
elim x.
intros a b d.
unfold pt in |- *.

*****
d : ConLn a b
a,b : Line
x : Twolines
*****
Incident (sig_rec (fun _ : sig (fun a0 : Point => and (Incident a0 (line1 {| line1 := a; line2 := b; Twol_cond := d |})) (Incident a0 (line2 {| line1 := a; line2 := b; Twol_cond := d |}))) => Point) (fun (x0 : Point) (_ : and (Incident x0 (line1 {| line1 := a; line2 := b; Twol_cond := d |})) (Incident x0 (line2 {| line1 := a; line2 := b; Twol_cond := d |}))) => x0) (point {| line1 := a; line2 := b; Twol_cond := d |})) (line2 {| line1 := a; line2 := b; Twol_cond := d |})
+++++
simpl in |- *.
-----
Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).
Proof.
intro x.
elim x.
intros a b d.
unfold pt in |- *.
simpl in |- *.

*****
d : ConLn a b
a,b : Line
x : Twolines
*****
Incident (sig_rec (fun _ : sig (fun a0 : Point => and (Incident a0 a) (Incident a0 b)) => Point) (fun (x0 : Point) (_ : and (Incident x0 a) (Incident x0 b)) => x0) (point {| line1 := a; line2 := b; Twol_cond := d |})) b
+++++
elim (point (Twol a b d)).
-----
Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).
Proof.
intro x.
elim x.
intros a b d.
unfold pt in |- *.
simpl in |- *.
elim (point (Twol a b d)).

*****
d : ConLn a b
a,b : Line
x : Twolines
*****
forall (x : Point) (p : and (Incident x (line1 {| line1 := a; line2 := b; Twol_cond := d |})) (Incident x (line2 {| line1 := a; line2 := b; Twol_cond := d |}))), Incident (sig_rec (fun _ : sig (fun a0 : Point => and (Incident a0 a) (Incident a0 b)) => Point) (fun (x0 : Point) (_ : and (Incident x0 a) (Incident x0 b)) => x0) (exist (fun a0 : Point => and (Incident a0 (line1 {| line1 := a; line2 := b; Twol_cond := d |})) (Incident a0 (line2 {| line1 := a; line2 := b; Twol_cond := d |}))) x p)) b
+++++
simpl in |- *.
-----
Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).
Proof.
intro x.
elim x.
intros a b d.
unfold pt in |- *.
simpl in |- *.
elim (point (Twol a b d)).
simpl in |- *.

*****
d : ConLn a b
a,b : Line
x : Twolines
*****
forall (x : Point) (_ : and (Incident x a) (Incident x b)), Incident x b
+++++
tauto.
-----
Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).
Proof.
intro x.
elim x.
intros a b d.
unfold pt in |- *.
simpl in |- *.
elim (point (Twol a b d)).
simpl in |- *.
tauto.

*****

*****

+++++
Qed.
-----
Hint Resolve inc_ln1 inc_ln2 inc_pt1 inc_pt2.
-----
Axiom\n  el_ax :\n    forall (x : Segment) (l m : Line),\n    DiLn l m ->\n    (Apart (origin x) l \/ Apart (extremity x) l) \/\n    Apart (origin x) m \/ Apart (extremity x) m.
-----
Axiom\n  cmp_apt_dipt :\n    forall (a b : Point) (l : Line), Apart a l -> DiPt a b \/ Apart b l.
-----
Axiom\n  cmp_apt_diln :\n    forall (a : Point) (l m : Line), Apart a l -> DiLn l m \/ Apart a m.
-----
Axiom cmp_con_diln : forall l m n : Line, ConLn l m -> DiLn m n \/ ConLn l n.
-----
Record Triangle : Set := Tri\n  {summit : Point; base : Segment; Tri_cond : Apart summit (ln base)}.
-----
Theorem Triangle_def : forall t : Triangle, Apart (summit t) (ln (base t)).
-----
Theorem Triangle_def : forall t : Triangle, Apart (summit t) (ln (base t)).

*****

*****
forall t : Triangle, Apart (summit t) (ln (base t))
+++++
Proof.
-----
Theorem Triangle_def : forall t : Triangle, Apart (summit t) (ln (base t)).
Proof.

*****

*****
forall t : Triangle, Apart (summit t) (ln (base t))
+++++
intro t.
-----
Theorem Triangle_def : forall t : Triangle, Apart (summit t) (ln (base t)).
Proof.
intro t.

*****
t : Triangle
*****
Apart (summit t) (ln (base t))
+++++
elim t.
-----
Theorem Triangle_def : forall t : Triangle, Apart (summit t) (ln (base t)).
Proof.
intro t.
elim t.

*****
t : Triangle
*****
forall (summit0 : Point) (base0 : Segment) (Tri_cond : Apart summit0 (ln base0)), Apart (summit {| summit := summit0; base := base0; Tri_cond := Tri_cond |}) (ln (base {| summit := summit0; base := base0; Tri_cond := Tri_cond |}))
+++++
simpl in |- *.
-----
Theorem Triangle_def : forall t : Triangle, Apart (summit t) (ln (base t)).
Proof.
intro t.
elim t.
simpl in |- *.

*****
t : Triangle
*****
forall (summit : Point) (base : Segment) (_ : Apart summit (ln base)), Apart summit (ln base)
+++++
intros s b H'.
-----
Theorem Triangle_def : forall t : Triangle, Apart (summit t) (ln (base t)).
Proof.
intro t.
elim t.
simpl in |- *.
intros s b H'.

*****
H' : Apart s (ln b)
b : Segment
s : Point
t : Triangle
*****
Apart s (ln b)
+++++
exact H'.
-----
Theorem Triangle_def : forall t : Triangle, Apart (summit t) (ln (base t)).
Proof.
intro t.
elim t.
simpl in |- *.
intros s b H'.
exact H'.

*****

*****

+++++
Qed.
-----
Hint Resolve Triangle_def.
-----
Definition SPar : Relation Line := fun l m : Line => Par l m /\ DiLn l m.
-----
Record Parallelogram : Set := Pgram\n  {side1 : Segment;\n   side2 : Segment;\n   side3 : Segment;\n   side4 : Segment;\n   connect1 : origin side3 = origin side1 /\ extremity side3 = origin side2;\n   connect2 :\n    origin side4 = extremity side1 /\ extremity side4 = extremity side2;\n   parsides_i : SPar (ln side1) (ln side2);\n   parsides_ii : SPar (ln side3) (ln side4)}.
-----
