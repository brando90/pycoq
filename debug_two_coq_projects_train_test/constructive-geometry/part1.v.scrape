Require Import basis.
-----
Theorem Uniqueness_of_constructed_lines :\n forall (x : Segment) (l : Line),\n Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).

*****

*****
forall (x : Segment) (l : Line) (_ : Incident (origin x) l) (_ : Incident (extremity x) l), EqLn l (ln x)
+++++
Proof.
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.

*****

*****
forall (x : Segment) (l : Line) (_ : Incident (origin x) l) (_ : Incident (extremity x) l), EqLn l (ln x)
+++++
intros x l.
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.
intros x l.

*****
l : Line
x : Segment
*****
forall (_ : Incident (origin x) l) (_ : Incident (extremity x) l), EqLn l (ln x)
+++++
generalize (inc_ln2 x).
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.
intros x l.
generalize (inc_ln2 x).

*****
l : Line
x : Segment
*****
forall (_ : Incident (extremity x) (ln x)) (_ : Incident (origin x) l) (_ : Incident (extremity x) l), EqLn l (ln x)
+++++
generalize (inc_ln1 x).
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.
intros x l.
generalize (inc_ln2 x).
generalize (inc_ln1 x).

*****
l : Line
x : Segment
*****
forall (_ : Incident (origin x) (ln x)) (_ : Incident (extremity x) (ln x)) (_ : Incident (origin x) l) (_ : Incident (extremity x) l), EqLn l (ln x)
+++++
unfold Incident in |- *.
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.
intros x l.
generalize (inc_ln2 x).
generalize (inc_ln1 x).
unfold Incident in |- *.

*****
l : Line
x : Segment
*****
forall (_ : not (Apart (origin x) (ln x))) (_ : not (Apart (extremity x) (ln x))) (_ : not (Apart (origin x) l)) (_ : not (Apart (extremity x) l)), EqLn l (ln x)
+++++
unfold EqLn in |- *.
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.
intros x l.
generalize (inc_ln2 x).
generalize (inc_ln1 x).
unfold Incident in |- *.
unfold EqLn in |- *.

*****
l : Line
x : Segment
*****
forall (_ : not (Apart (origin x) (ln x))) (_ : not (Apart (extremity x) (ln x))) (_ : not (Apart (origin x) l)) (_ : not (Apart (extremity x) l)), Negation Line DiLn l (ln x)
+++++
unfold Negation in |- *.
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.
intros x l.
generalize (inc_ln2 x).
generalize (inc_ln1 x).
unfold Incident in |- *.
unfold EqLn in |- *.
unfold Negation in |- *.

*****
l : Line
x : Segment
*****
forall (_ : not (Apart (origin x) (ln x))) (_ : not (Apart (extremity x) (ln x))) (_ : not (Apart (origin x) l)) (_ : not (Apart (extremity x) l)), not (DiLn l (ln x))
+++++
intros H' H'0 H'1 H'2.
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.
intros x l.
generalize (inc_ln2 x).
generalize (inc_ln1 x).
unfold Incident in |- *.
unfold EqLn in |- *.
unfold Negation in |- *.
intros H' H'0 H'1 H'2.

*****
H'2 : not (Apart (extremity x) l)
H'1 : not (Apart (origin x) l)
H'0 : not (Apart (extremity x) (ln x))
H' : not (Apart (origin x) (ln x))
l : Line
x : Segment
*****
not (DiLn l (ln x))
+++++
red in |- *.
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.
intros x l.
generalize (inc_ln2 x).
generalize (inc_ln1 x).
unfold Incident in |- *.
unfold EqLn in |- *.
unfold Negation in |- *.
intros H' H'0 H'1 H'2.
red in |- *.

*****
H'2 : not (Apart (extremity x) l)
H'1 : not (Apart (origin x) l)
H'0 : not (Apart (extremity x) (ln x))
H' : not (Apart (origin x) (ln x))
l : Line
x : Segment
*****
forall _ : DiLn l (ln x), False
+++++
intro H'3.
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.
intros x l.
generalize (inc_ln2 x).
generalize (inc_ln1 x).
unfold Incident in |- *.
unfold EqLn in |- *.
unfold Negation in |- *.
intros H' H'0 H'1 H'2.
red in |- *.
intro H'3.

*****
H'3 : DiLn l (ln x)
H'2 : not (Apart (extremity x) l)
H'1 : not (Apart (origin x) l)
H'0 : not (Apart (extremity x) (ln x))
H' : not (Apart (origin x) (ln x))
l : Line
x : Segment
*****
False
+++++
lapply (el_ax x l (ln x)).
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.
intros x l.
generalize (inc_ln2 x).
generalize (inc_ln1 x).
unfold Incident in |- *.
unfold EqLn in |- *.
unfold Negation in |- *.
intros H' H'0 H'1 H'2.
red in |- *.
intro H'3.
lapply (el_ax x l (ln x)).

*****
H'3 : DiLn l (ln x)
H'2 : not (Apart (extremity x) l)
H'1 : not (Apart (origin x) l)
H'0 : not (Apart (extremity x) (ln x))
H' : not (Apart (origin x) (ln x))
l : Line
x : Segment
*****
forall _ : or (or (Apart (origin x) l) (Apart (extremity x) l)) (or (Apart (origin x) (ln x)) (Apart (extremity x) (ln x))), False
+++++
trivial.
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.
intros x l.
generalize (inc_ln2 x).
generalize (inc_ln1 x).
unfold Incident in |- *.
unfold EqLn in |- *.
unfold Negation in |- *.
intros H' H'0 H'1 H'2.
red in |- *.
intro H'3.
lapply (el_ax x l (ln x)).
trivial.

*****
H'3 : DiLn l (ln x)
H'2 : not (Apart (extremity x) l)
H'1 : not (Apart (origin x) l)
H'0 : not (Apart (extremity x) (ln x))
H' : not (Apart (origin x) (ln x))
l : Line
x : Segment
*****
forall _ : or (or (Apart (origin x) l) (Apart (extremity x) l)) (or (Apart (origin x) (ln x)) (Apart (extremity x) (ln x))), False
+++++
tauto.
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.
intros x l.
generalize (inc_ln2 x).
generalize (inc_ln1 x).
unfold Incident in |- *.
unfold EqLn in |- *.
unfold Negation in |- *.
intros H' H'0 H'1 H'2.
red in |- *.
intro H'3.
lapply (el_ax x l (ln x)).

*****
H'3 : DiLn l (ln x)
H'2 : not (Apart (extremity x) l)
H'1 : not (Apart (origin x) l)
H'0 : not (Apart (extremity x) (ln x))
H' : not (Apart (origin x) (ln x))
l : Line
x : Segment
*****
DiLn l (ln x)
+++++
trivial.
-----
Theorem Uniqueness_of_constructed_lines : forall (x : Segment) (l : Line), Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).
Proof.
intros x l.
generalize (inc_ln2 x).
generalize (inc_ln1 x).
unfold Incident in |- *.
unfold EqLn in |- *.
unfold Negation in |- *.
intros H' H'0 H'1 H'2.
red in |- *.
intro H'3.
lapply (el_ax x l (ln x)).

*****

*****

+++++
Qed.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.

*****

*****
forall (l m : Line) (_ : ConLn l m), DiLn l m
+++++
Proof.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.

*****

*****
forall (l m : Line) (_ : ConLn l m), DiLn l m
+++++
intros l m H'.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.
intros l m H'.

*****
H' : ConLn l m
l,m : Line
*****
DiLn l m
+++++
lapply (cmp_con_diln l m l).
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.
intros l m H'.
lapply (cmp_con_diln l m l).

*****
H' : ConLn l m
l,m : Line
*****
forall _ : or (DiLn m l) (ConLn l l), DiLn l m
+++++
trivial.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.
intros l m H'.
lapply (cmp_con_diln l m l).
trivial.

*****
H' : ConLn l m
l,m : Line
*****
forall _ : or (DiLn m l) (ConLn l l), DiLn l m
+++++
intro H'0.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.
intros l m H'.
lapply (cmp_con_diln l m l).
trivial.
intro H'0.

*****
H'0 : or (DiLn m l) (ConLn l l)
H' : ConLn l m
l,m : Line
*****
DiLn l m
+++++
elim H'0.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.
intros l m H'.
lapply (cmp_con_diln l m l).
trivial.
intro H'0.
elim H'0.

*****
H'0 : or (DiLn m l) (ConLn l l)
H' : ConLn l m
l,m : Line
*****
forall _ : DiLn m l, DiLn l m
+++++
auto.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.
intros l m H'.
lapply (cmp_con_diln l m l).
trivial.
intro H'0.
elim H'0.

*****
H'0 : or (DiLn m l) (ConLn l l)
H' : ConLn l m
l,m : Line
*****
forall _ : ConLn l l, DiLn l m
+++++
auto.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.
intros l m H'.
lapply (cmp_con_diln l m l).
trivial.
intro H'0.
elim H'0.
auto.

*****
H'0 : or (DiLn m l) (ConLn l l)
H' : ConLn l m
l,m : Line
*****
forall _ : ConLn l l, DiLn l m
+++++
intro H'1.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.
intros l m H'.
lapply (cmp_con_diln l m l).
trivial.
intro H'0.
elim H'0.
auto.
intro H'1.

*****
H'1 : ConLn l l
H'0 : or (DiLn m l) (ConLn l l)
H' : ConLn l m
l,m : Line
*****
DiLn l m
+++++
elim apart_con.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.
intros l m H'.
lapply (cmp_con_diln l m l).
trivial.
intro H'0.
elim H'0.
auto.
intro H'1.
elim apart_con.

*****
H'1 : ConLn l l
H'0 : or (DiLn m l) (ConLn l l)
H' : ConLn l m
l,m : Line
*****
forall (_ : Irreflexive Line ConLn) (_ : Separating Line ConLn), DiLn l m
+++++
intro H'2.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.
intros l m H'.
lapply (cmp_con_diln l m l).
trivial.
intro H'0.
elim H'0.
auto.
intro H'1.
elim apart_con.
intro H'2.

*****
H'2 : Irreflexive Line ConLn
H'1 : ConLn l l
H'0 : or (DiLn m l) (ConLn l l)
H' : ConLn l m
l,m : Line
*****
forall _ : Separating Line ConLn, DiLn l m
+++++
elim (H'2 l).
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.
intros l m H'.
lapply (cmp_con_diln l m l).
trivial.
intro H'0.
elim H'0.
auto.
intro H'1.
elim apart_con.
intro H'2.
elim (H'2 l).

*****
H'2 : Irreflexive Line ConLn
H'1 : ConLn l l
H'0 : or (DiLn m l) (ConLn l l)
H' : ConLn l m
l,m : Line
*****
ConLn l l
+++++
trivial.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.
intros l m H'.
lapply (cmp_con_diln l m l).

*****
H' : ConLn l m
l,m : Line
*****
ConLn l m
+++++
trivial.
-----
Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.
Proof.
intros l m H'.
lapply (cmp_con_diln l m l).

*****

*****

+++++
Qed.
-----
Hint Resolve Convergent_imp_distinct.
-----
Theorem Uniqueness_of_constructed_points :\n forall (x : Twolines) (a : Point),\n Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).

*****

*****
forall (x : Twolines) (a : Point) (_ : Incident a (line1 x)) (_ : Incident a (line2 x)), EqPt a (pt x)
+++++
Proof.
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.

*****

*****
forall (x : Twolines) (a : Point) (_ : Incident a (line1 x)) (_ : Incident a (line2 x)), EqPt a (pt x)
+++++
intro x.
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.

*****
x : Twolines
*****
forall (a : Point) (_ : Incident a (line1 x)) (_ : Incident a (line2 x)), EqPt a (pt x)
+++++
generalize (inc_pt2 x).
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).

*****
x : Twolines
*****
forall (_ : Incident (pt x) (line2 x)) (a : Point) (_ : Incident a (line1 x)) (_ : Incident a (line2 x)), EqPt a (pt x)
+++++
generalize (inc_pt1 x).
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).
generalize (inc_pt1 x).

*****
x : Twolines
*****
forall (_ : Incident (pt x) (line1 x)) (_ : Incident (pt x) (line2 x)) (a : Point) (_ : Incident a (line1 x)) (_ : Incident a (line2 x)), EqPt a (pt x)
+++++
unfold Incident in |- *.
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).
generalize (inc_pt1 x).
unfold Incident in |- *.

*****
x : Twolines
*****
forall (_ : not (Apart (pt x) (line1 x))) (_ : not (Apart (pt x) (line2 x))) (a : Point) (_ : not (Apart a (line1 x))) (_ : not (Apart a (line2 x))), EqPt a (pt x)
+++++
unfold EqPt in |- *.
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).
generalize (inc_pt1 x).
unfold Incident in |- *.
unfold EqPt in |- *.

*****
x : Twolines
*****
forall (_ : not (Apart (pt x) (line1 x))) (_ : not (Apart (pt x) (line2 x))) (a : Point) (_ : not (Apart a (line1 x))) (_ : not (Apart a (line2 x))), Negation Point DiPt a (pt x)
+++++
unfold Negation in |- *.
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).
generalize (inc_pt1 x).
unfold Incident in |- *.
unfold EqPt in |- *.
unfold Negation in |- *.

*****
x : Twolines
*****
forall (_ : not (Apart (pt x) (line1 x))) (_ : not (Apart (pt x) (line2 x))) (a : Point) (_ : not (Apart a (line1 x))) (_ : not (Apart a (line2 x))), not (DiPt a (pt x))
+++++
intros H' H'0 a H'1 H'2.
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).
generalize (inc_pt1 x).
unfold Incident in |- *.
unfold EqPt in |- *.
unfold Negation in |- *.
intros H' H'0 a H'1 H'2.

*****
H'2 : not (Apart a (line2 x))
H'1 : not (Apart a (line1 x))
a : Point
H'0 : not (Apart (pt x) (line2 x))
H' : not (Apart (pt x) (line1 x))
x : Twolines
*****
not (DiPt a (pt x))
+++++
red in |- *.
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).
generalize (inc_pt1 x).
unfold Incident in |- *.
unfold EqPt in |- *.
unfold Negation in |- *.
intros H' H'0 a H'1 H'2.
red in |- *.

*****
H'2 : not (Apart a (line2 x))
H'1 : not (Apart a (line1 x))
a : Point
H'0 : not (Apart (pt x) (line2 x))
H' : not (Apart (pt x) (line1 x))
x : Twolines
*****
forall _ : DiPt a (pt x), False
+++++
intro H'3.
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).
generalize (inc_pt1 x).
unfold Incident in |- *.
unfold EqPt in |- *.
unfold Negation in |- *.
intros H' H'0 a H'1 H'2.
red in |- *.
intro H'3.

*****
H'3 : DiPt a (pt x)
H'2 : not (Apart a (line2 x))
H'1 : not (Apart a (line1 x))
a : Point
H'0 : not (Apart (pt x) (line2 x))
H' : not (Apart (pt x) (line1 x))
x : Twolines
*****
False
+++++
lapply (el_ax (Seg a (pt x) H'3) (line1 x) (line2 x)).
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).
generalize (inc_pt1 x).
unfold Incident in |- *.
unfold EqPt in |- *.
unfold Negation in |- *.
intros H' H'0 a H'1 H'2.
red in |- *.
intro H'3.
lapply (el_ax (Seg a (pt x) H'3) (line1 x) (line2 x)).

*****
H'3 : DiPt a (pt x)
H'2 : not (Apart a (line2 x))
H'1 : not (Apart a (line1 x))
a : Point
H'0 : not (Apart (pt x) (line2 x))
H' : not (Apart (pt x) (line1 x))
x : Twolines
*****
forall _ : or (or (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |}) (line1 x)) (Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |}) (line1 x))) (or (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |}) (line2 x)) (Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |}) (line2 x))), False
+++++
simpl in |- *.
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).
generalize (inc_pt1 x).
unfold Incident in |- *.
unfold EqPt in |- *.
unfold Negation in |- *.
intros H' H'0 a H'1 H'2.
red in |- *.
intro H'3.
lapply (el_ax (Seg a (pt x) H'3) (line1 x) (line2 x)).
simpl in |- *.

*****
H'3 : DiPt a (pt x)
H'2 : not (Apart a (line2 x))
H'1 : not (Apart a (line1 x))
a : Point
H'0 : not (Apart (pt x) (line2 x))
H' : not (Apart (pt x) (line1 x))
x : Twolines
*****
forall _ : or (or (Apart a (line1 x)) (Apart (pt x) (line1 x))) (or (Apart a (line2 x)) (Apart (pt x) (line2 x))), False
+++++
tauto.
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).
generalize (inc_pt1 x).
unfold Incident in |- *.
unfold EqPt in |- *.
unfold Negation in |- *.
intros H' H'0 a H'1 H'2.
red in |- *.
intro H'3.
lapply (el_ax (Seg a (pt x) H'3) (line1 x) (line2 x)).

*****
H'3 : DiPt a (pt x)
H'2 : not (Apart a (line2 x))
H'1 : not (Apart a (line1 x))
a : Point
H'0 : not (Apart (pt x) (line2 x))
H' : not (Apart (pt x) (line1 x))
x : Twolines
*****
DiLn (line1 x) (line2 x)
+++++
simpl in |- *.
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).
generalize (inc_pt1 x).
unfold Incident in |- *.
unfold EqPt in |- *.
unfold Negation in |- *.
intros H' H'0 a H'1 H'2.
red in |- *.
intro H'3.
lapply (el_ax (Seg a (pt x) H'3) (line1 x) (line2 x)).
simpl in |- *.

*****
H'3 : DiPt a (pt x)
H'2 : not (Apart a (line2 x))
H'1 : not (Apart a (line1 x))
a : Point
H'0 : not (Apart (pt x) (line2 x))
H' : not (Apart (pt x) (line1 x))
x : Twolines
*****
DiLn (line1 x) (line2 x)
+++++
elim x.
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).
generalize (inc_pt1 x).
unfold Incident in |- *.
unfold EqPt in |- *.
unfold Negation in |- *.
intros H' H'0 a H'1 H'2.
red in |- *.
intro H'3.
lapply (el_ax (Seg a (pt x) H'3) (line1 x) (line2 x)).
simpl in |- *.
elim x.

*****
H'3 : DiPt a (pt x)
H'2 : not (Apart a (line2 x))
H'1 : not (Apart a (line1 x))
a : Point
H'0 : not (Apart (pt x) (line2 x))
H' : not (Apart (pt x) (line1 x))
x : Twolines
*****
forall (line3 line4 : Line) (Twol_cond : ConLn line3 line4), DiLn (line1 {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |}) (line2 {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |})
+++++
auto.
-----
Theorem Uniqueness_of_constructed_points : forall (x : Twolines) (a : Point), Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).
Proof.
intro x.
generalize (inc_pt2 x).
generalize (inc_pt1 x).
unfold Incident in |- *.
unfold EqPt in |- *.
unfold Negation in |- *.
intros H' H'0 a H'1 H'2.
red in |- *.
intro H'3.
lapply (el_ax (Seg a (pt x) H'3) (line1 x) (line2 x)).

*****

*****

+++++
Qed.
-----
Theorem cong_eqpt_apt :\n forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.
-----
Theorem cong_eqpt_apt : forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.

*****

*****
forall (a b : Point) (l : Line) (_ : Apart a l) (_ : EqPt a b), Apart b l
+++++
Proof.
-----
Theorem cong_eqpt_apt : forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.
Proof.

*****

*****
forall (a b : Point) (l : Line) (_ : Apart a l) (_ : EqPt a b), Apart b l
+++++
intros a b l H' H'0.
-----
Theorem cong_eqpt_apt : forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.
Proof.
intros a b l H' H'0.

*****
H'0 : EqPt a b
H' : Apart a l
l : Line
a,b : Point
*****
Apart b l
+++++
elim (cmp_apt_dipt a b l).
-----
Theorem cong_eqpt_apt : forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.
Proof.
intros a b l H' H'0.
elim (cmp_apt_dipt a b l).

*****
H'0 : EqPt a b
H' : Apart a l
l : Line
a,b : Point
*****
forall _ : DiPt a b, Apart b l
+++++
auto.
-----
Theorem cong_eqpt_apt : forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.
Proof.
intros a b l H' H'0.
elim (cmp_apt_dipt a b l).
auto.

*****
H'0 : EqPt a b
H' : Apart a l
l : Line
a,b : Point
*****
forall _ : DiPt a b, Apart b l
+++++
intro H'1.
-----
Theorem cong_eqpt_apt : forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.
Proof.
intros a b l H' H'0.
elim (cmp_apt_dipt a b l).
auto.
intro H'1.

*****
H'1 : DiPt a b
H'0 : EqPt a b
H' : Apart a l
l : Line
a,b : Point
*****
Apart b l
+++++
elim H'0.
-----
Theorem cong_eqpt_apt : forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.
Proof.
intros a b l H' H'0.
elim (cmp_apt_dipt a b l).
auto.
intro H'1.
elim H'0.

*****
H'1 : DiPt a b
H'0 : EqPt a b
H' : Apart a l
l : Line
a,b : Point
*****
DiPt a b
+++++
trivial.
-----
Theorem cong_eqpt_apt : forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.
Proof.
intros a b l H' H'0.
elim (cmp_apt_dipt a b l).

*****
H'0 : EqPt a b
H' : Apart a l
l : Line
a,b : Point
*****
forall _ : Apart b l, Apart b l
+++++
auto.
-----
Theorem cong_eqpt_apt : forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.
Proof.
intros a b l H' H'0.
elim (cmp_apt_dipt a b l).

*****
H'0 : EqPt a b
H' : Apart a l
l : Line
a,b : Point
*****
Apart a l
+++++
auto.
-----
Theorem cong_eqpt_apt : forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.
Proof.
intros a b l H' H'0.
elim (cmp_apt_dipt a b l).

*****

*****

+++++
Qed.
-----
Theorem cong_eqln_apt :\n forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.
-----
Theorem cong_eqln_apt : forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.

*****

*****
forall (a : Point) (l m : Line) (_ : Apart a l) (_ : EqLn l m), Apart a m
+++++
Proof.
-----
Theorem cong_eqln_apt : forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.
Proof.

*****

*****
forall (a : Point) (l m : Line) (_ : Apart a l) (_ : EqLn l m), Apart a m
+++++
intros a l m H' H'0.
-----
Theorem cong_eqln_apt : forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.
Proof.
intros a l m H' H'0.

*****
H'0 : EqLn l m
H' : Apart a l
l,m : Line
a : Point
*****
Apart a m
+++++
elim (cmp_apt_diln a l m).
-----
Theorem cong_eqln_apt : forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.
Proof.
intros a l m H' H'0.
elim (cmp_apt_diln a l m).

*****
H'0 : EqLn l m
H' : Apart a l
l,m : Line
a : Point
*****
forall _ : DiLn l m, Apart a m
+++++
auto.
-----
Theorem cong_eqln_apt : forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.
Proof.
intros a l m H' H'0.
elim (cmp_apt_diln a l m).
auto.

*****
H'0 : EqLn l m
H' : Apart a l
l,m : Line
a : Point
*****
forall _ : DiLn l m, Apart a m
+++++
intro H'1.
-----
Theorem cong_eqln_apt : forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.
Proof.
intros a l m H' H'0.
elim (cmp_apt_diln a l m).
auto.
intro H'1.

*****
H'1 : DiLn l m
H'0 : EqLn l m
H' : Apart a l
l,m : Line
a : Point
*****
Apart a m
+++++
elim H'0.
-----
Theorem cong_eqln_apt : forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.
Proof.
intros a l m H' H'0.
elim (cmp_apt_diln a l m).
auto.
intro H'1.
elim H'0.

*****
H'1 : DiLn l m
H'0 : EqLn l m
H' : Apart a l
l,m : Line
a : Point
*****
DiLn l m
+++++
trivial.
-----
Theorem cong_eqln_apt : forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.
Proof.
intros a l m H' H'0.
elim (cmp_apt_diln a l m).

*****
H'0 : EqLn l m
H' : Apart a l
l,m : Line
a : Point
*****
forall _ : Apart a m, Apart a m
+++++
auto.
-----
Theorem cong_eqln_apt : forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.
Proof.
intros a l m H' H'0.
elim (cmp_apt_diln a l m).

*****
H'0 : EqLn l m
H' : Apart a l
l,m : Line
a : Point
*****
Apart a l
+++++
auto.
-----
Theorem cong_eqln_apt : forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.
Proof.
intros a l m H' H'0.
elim (cmp_apt_diln a l m).

*****

*****

+++++
Qed.
-----
Theorem cong_eqpt_inc :\n forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.
-----
Theorem cong_eqpt_inc : forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.

*****

*****
forall (a b : Point) (l : Line) (_ : Incident a l) (_ : EqPt a b), Incident b l
+++++
Proof.
-----
Theorem cong_eqpt_inc : forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.
Proof.

*****

*****
forall (a b : Point) (l : Line) (_ : Incident a l) (_ : EqPt a b), Incident b l
+++++
unfold Incident in |- *.
-----
Theorem cong_eqpt_inc : forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.
Proof.
unfold Incident in |- *.

*****

*****
forall (a b : Point) (l : Line) (_ : not (Apart a l)) (_ : EqPt a b), not (Apart b l)
+++++
intros a b l H' H'0.
-----
Theorem cong_eqpt_inc : forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.
Proof.
unfold Incident in |- *.
intros a b l H' H'0.

*****
H'0 : EqPt a b
H' : not (Apart a l)
l : Line
a,b : Point
*****
not (Apart b l)
+++++
red in |- *.
-----
Theorem cong_eqpt_inc : forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.
Proof.
unfold Incident in |- *.
intros a b l H' H'0.
red in |- *.

*****
H'0 : EqPt a b
H' : not (Apart a l)
l : Line
a,b : Point
*****
forall _ : Apart b l, False
+++++
intro H'1.
-----
Theorem cong_eqpt_inc : forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.
Proof.
unfold Incident in |- *.
intros a b l H' H'0.
red in |- *.
intro H'1.

*****
H'1 : Apart b l
H'0 : EqPt a b
H' : not (Apart a l)
l : Line
a,b : Point
*****
False
+++++
apply H'.
-----
Theorem cong_eqpt_inc : forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.
Proof.
unfold Incident in |- *.
intros a b l H' H'0.
red in |- *.
intro H'1.
apply H'.

*****
H'1 : Apart b l
H'0 : EqPt a b
H' : not (Apart a l)
l : Line
a,b : Point
*****
Apart a l
+++++
apply cong_eqpt_apt with (a := b).
-----
Theorem cong_eqpt_inc : forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.
Proof.
unfold Incident in |- *.
intros a b l H' H'0.
red in |- *.
intro H'1.
apply H'.
apply cong_eqpt_apt with (a := b).

*****
H'1 : Apart b l
H'0 : EqPt a b
H' : not (Apart a l)
l : Line
a,b : Point
*****
Apart b l
+++++
auto.
-----
Theorem cong_eqpt_inc : forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.
Proof.
unfold Incident in |- *.
intros a b l H' H'0.
red in |- *.
intro H'1.
apply H'.
apply cong_eqpt_apt with (a := b).

*****
H'1 : Apart b l
H'0 : EqPt a b
H' : not (Apart a l)
l : Line
a,b : Point
*****
EqPt b a
+++++
auto.
-----
Theorem cong_eqpt_inc : forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.
Proof.
unfold Incident in |- *.
intros a b l H' H'0.
red in |- *.
intro H'1.
apply H'.
apply cong_eqpt_apt with (a := b).

*****

*****

+++++
Qed.
-----
Theorem cong_eqln_inc :\n forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.
-----
Theorem cong_eqln_inc : forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.

*****

*****
forall (a : Point) (l m : Line) (_ : Incident a l) (_ : EqLn l m), Incident a m
+++++
Proof.
-----
Theorem cong_eqln_inc : forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.
Proof.

*****

*****
forall (a : Point) (l m : Line) (_ : Incident a l) (_ : EqLn l m), Incident a m
+++++
unfold Incident in |- *.
-----
Theorem cong_eqln_inc : forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.
Proof.
unfold Incident in |- *.

*****

*****
forall (a : Point) (l m : Line) (_ : not (Apart a l)) (_ : EqLn l m), not (Apart a m)
+++++
intros a l m H' H'0.
-----
Theorem cong_eqln_inc : forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.
Proof.
unfold Incident in |- *.
intros a l m H' H'0.

*****
H'0 : EqLn l m
H' : not (Apart a l)
l,m : Line
a : Point
*****
not (Apart a m)
+++++
red in |- *.
-----
Theorem cong_eqln_inc : forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.
Proof.
unfold Incident in |- *.
intros a l m H' H'0.
red in |- *.

*****
H'0 : EqLn l m
H' : not (Apart a l)
l,m : Line
a : Point
*****
forall _ : Apart a m, False
+++++
intro H'1.
-----
Theorem cong_eqln_inc : forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.
Proof.
unfold Incident in |- *.
intros a l m H' H'0.
red in |- *.
intro H'1.

*****
H'1 : Apart a m
H'0 : EqLn l m
H' : not (Apart a l)
l,m : Line
a : Point
*****
False
+++++
apply H'.
-----
Theorem cong_eqln_inc : forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.
Proof.
unfold Incident in |- *.
intros a l m H' H'0.
red in |- *.
intro H'1.
apply H'.

*****
H'1 : Apart a m
H'0 : EqLn l m
H' : not (Apart a l)
l,m : Line
a : Point
*****
Apart a l
+++++
apply cong_eqln_apt with (l := m).
-----
Theorem cong_eqln_inc : forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.
Proof.
unfold Incident in |- *.
intros a l m H' H'0.
red in |- *.
intro H'1.
apply H'.
apply cong_eqln_apt with (l := m).

*****
H'1 : Apart a m
H'0 : EqLn l m
H' : not (Apart a l)
l,m : Line
a : Point
*****
Apart a m
+++++
auto.
-----
Theorem cong_eqln_inc : forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.
Proof.
unfold Incident in |- *.
intros a l m H' H'0.
red in |- *.
intro H'1.
apply H'.
apply cong_eqln_apt with (l := m).

*****
H'1 : Apart a m
H'0 : EqLn l m
H' : not (Apart a l)
l,m : Line
a : Point
*****
EqLn m l
+++++
auto.
-----
Theorem cong_eqln_inc : forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.
Proof.
unfold Incident in |- *.
intros a l m H' H'0.
red in |- *.
intro H'1.
apply H'.
apply cong_eqln_apt with (l := m).

*****

*****

+++++
Qed.
-----
Theorem cong_eqln_con :\n forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.
-----
Theorem cong_eqln_con : forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.

*****

*****
forall (l m n : Line) (_ : ConLn l m) (_ : EqLn m n), ConLn l n
+++++
Proof.
-----
Theorem cong_eqln_con : forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.
Proof.

*****

*****
forall (l m n : Line) (_ : ConLn l m) (_ : EqLn m n), ConLn l n
+++++
intros l m n H' H'0.
-----
Theorem cong_eqln_con : forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.
Proof.
intros l m n H' H'0.

*****
H'0 : EqLn m n
H' : ConLn l m
l,m,n : Line
*****
ConLn l n
+++++
elim (cmp_con_diln l m n).
-----
Theorem cong_eqln_con : forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim (cmp_con_diln l m n).

*****
H'0 : EqLn m n
H' : ConLn l m
l,m,n : Line
*****
forall _ : DiLn m n, ConLn l n
+++++
auto.
-----
Theorem cong_eqln_con : forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim (cmp_con_diln l m n).
auto.

*****
H'0 : EqLn m n
H' : ConLn l m
l,m,n : Line
*****
forall _ : DiLn m n, ConLn l n
+++++
intro H'1.
-----
Theorem cong_eqln_con : forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim (cmp_con_diln l m n).
auto.
intro H'1.

*****
H'1 : DiLn m n
H'0 : EqLn m n
H' : ConLn l m
l,m,n : Line
*****
ConLn l n
+++++
elim H'0.
-----
Theorem cong_eqln_con : forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim (cmp_con_diln l m n).
auto.
intro H'1.
elim H'0.

*****
H'1 : DiLn m n
H'0 : EqLn m n
H' : ConLn l m
l,m,n : Line
*****
DiLn m n
+++++
trivial.
-----
Theorem cong_eqln_con : forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim (cmp_con_diln l m n).

*****
H'0 : EqLn m n
H' : ConLn l m
l,m,n : Line
*****
forall _ : ConLn l n, ConLn l n
+++++
auto.
-----
Theorem cong_eqln_con : forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim (cmp_con_diln l m n).

*****
H'0 : EqLn m n
H' : ConLn l m
l,m,n : Line
*****
ConLn l m
+++++
auto.
-----
Theorem cong_eqln_con : forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim (cmp_con_diln l m n).

*****

*****

+++++
Qed.
-----
Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.
-----
Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.

*****

*****
forall (l m n : Line) (_ : Par l m) (_ : EqLn m n), Par l n
+++++
Proof.
-----
Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.
Proof.

*****

*****
forall (l m n : Line) (_ : Par l m) (_ : EqLn m n), Par l n
+++++
unfold Par in |- *.
-----
Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.
Proof.
unfold Par in |- *.

*****

*****
forall (l m n : Line) (_ : Negation Line ConLn l m) (_ : EqLn m n), Negation Line ConLn l n
+++++
unfold Negation in |- *.
-----
Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.
Proof.
unfold Par in |- *.
unfold Negation in |- *.

*****

*****
forall (l m n : Line) (_ : not (ConLn l m)) (_ : EqLn m n), not (ConLn l n)
+++++
intros l m n H' H'0.
-----
Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.
Proof.
unfold Par in |- *.
unfold Negation in |- *.
intros l m n H' H'0.

*****
H'0 : EqLn m n
H' : not (ConLn l m)
l,m,n : Line
*****
not (ConLn l n)
+++++
red in |- *.
-----
Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.
Proof.
unfold Par in |- *.
unfold Negation in |- *.
intros l m n H' H'0.
red in |- *.

*****
H'0 : EqLn m n
H' : not (ConLn l m)
l,m,n : Line
*****
forall _ : ConLn l n, False
+++++
intro H'1.
-----
Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.
Proof.
unfold Par in |- *.
unfold Negation in |- *.
intros l m n H' H'0.
red in |- *.
intro H'1.

*****
H'1 : ConLn l n
H'0 : EqLn m n
H' : not (ConLn l m)
l,m,n : Line
*****
False
+++++
apply H'.
-----
Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.
Proof.
unfold Par in |- *.
unfold Negation in |- *.
intros l m n H' H'0.
red in |- *.
intro H'1.
apply H'.

*****
H'1 : ConLn l n
H'0 : EqLn m n
H' : not (ConLn l m)
l,m,n : Line
*****
ConLn l m
+++++
apply cong_eqln_con with (m := n).
-----
Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.
Proof.
unfold Par in |- *.
unfold Negation in |- *.
intros l m n H' H'0.
red in |- *.
intro H'1.
apply H'.
apply cong_eqln_con with (m := n).

*****
H'1 : ConLn l n
H'0 : EqLn m n
H' : not (ConLn l m)
l,m,n : Line
*****
ConLn l n
+++++
auto.
-----
Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.
Proof.
unfold Par in |- *.
unfold Negation in |- *.
intros l m n H' H'0.
red in |- *.
intro H'1.
apply H'.
apply cong_eqln_con with (m := n).

*****
H'1 : ConLn l n
H'0 : EqLn m n
H' : not (ConLn l m)
l,m,n : Line
*****
EqLn n m
+++++
auto.
-----
Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.
Proof.
unfold Par in |- *.
unfold Negation in |- *.
intros l m n H' H'0.
red in |- *.
intro H'1.
apply H'.
apply cong_eqln_con with (m := n).

*****

*****

+++++
Qed.
-----
Theorem cong_eqpt_dipt :\n forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.
-----
Theorem cong_eqpt_dipt : forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.

*****

*****
forall (a b c : Point) (_ : DiPt a b) (_ : EqPt b c), DiPt a c
+++++
Proof.
-----
Theorem cong_eqpt_dipt : forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.
Proof.

*****

*****
forall (a b c : Point) (_ : DiPt a b) (_ : EqPt b c), DiPt a c
+++++
intros a b c H' H'0.
-----
Theorem cong_eqpt_dipt : forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.
Proof.
intros a b c H' H'0.

*****
H'0 : EqPt b c
H' : DiPt a b
a,b,c : Point
*****
DiPt a c
+++++
elim apart_dipt.
-----
Theorem cong_eqpt_dipt : forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.
Proof.
intros a b c H' H'0.
elim apart_dipt.

*****
H'0 : EqPt b c
H' : DiPt a b
a,b,c : Point
*****
forall (_ : Irreflexive Point DiPt) (_ : Separating Point DiPt), DiPt a c
+++++
unfold Separating at 1 in |- *.
-----
Theorem cong_eqpt_dipt : forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.
Proof.
intros a b c H' H'0.
elim apart_dipt.
unfold Separating at 1 in |- *.

*****
H'0 : EqPt b c
H' : DiPt a b
a,b,c : Point
*****
forall (_ : Irreflexive Point DiPt) (_ : forall (x y z : Point) (_ : DiPt x y), or (DiPt x z) (DiPt y z)), DiPt a c
+++++
intros H'1 H'2.
-----
Theorem cong_eqpt_dipt : forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.
Proof.
intros a b c H' H'0.
elim apart_dipt.
unfold Separating at 1 in |- *.
intros H'1 H'2.

*****
H'2 : forall (x y z : Point) (_ : DiPt x y), or (DiPt x z) (DiPt y z)
H'1 : Irreflexive Point DiPt
H'0 : EqPt b c
H' : DiPt a b
a,b,c : Point
*****
DiPt a c
+++++
elim (H'2 a b c).
-----
Theorem cong_eqpt_dipt : forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.
Proof.
intros a b c H' H'0.
elim apart_dipt.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 a b c).

*****
H'2 : forall (x y z : Point) (_ : DiPt x y), or (DiPt x z) (DiPt y z)
H'1 : Irreflexive Point DiPt
H'0 : EqPt b c
H' : DiPt a b
a,b,c : Point
*****
forall _ : DiPt a c, DiPt a c
+++++
trivial.
-----
Theorem cong_eqpt_dipt : forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.
Proof.
intros a b c H' H'0.
elim apart_dipt.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 a b c).

*****
H'2 : forall (x y z : Point) (_ : DiPt x y), or (DiPt x z) (DiPt y z)
H'1 : Irreflexive Point DiPt
H'0 : EqPt b c
H' : DiPt a b
a,b,c : Point
*****
forall _ : DiPt b c, DiPt a c
+++++
trivial.
-----
Theorem cong_eqpt_dipt : forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.
Proof.
intros a b c H' H'0.
elim apart_dipt.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 a b c).
trivial.

*****
H'2 : forall (x y z : Point) (_ : DiPt x y), or (DiPt x z) (DiPt y z)
H'1 : Irreflexive Point DiPt
H'0 : EqPt b c
H' : DiPt a b
a,b,c : Point
*****
forall _ : DiPt b c, DiPt a c
+++++
intro H'3.
-----
Theorem cong_eqpt_dipt : forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.
Proof.
intros a b c H' H'0.
elim apart_dipt.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 a b c).
trivial.
intro H'3.

*****
H'3 : DiPt b c
H'2 : forall (x y z : Point) (_ : DiPt x y), or (DiPt x z) (DiPt y z)
H'1 : Irreflexive Point DiPt
H'0 : EqPt b c
H' : DiPt a b
a,b,c : Point
*****
DiPt a c
+++++
elim H'0.
-----
Theorem cong_eqpt_dipt : forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.
Proof.
intros a b c H' H'0.
elim apart_dipt.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 a b c).
trivial.
intro H'3.
elim H'0.

*****
H'3 : DiPt b c
H'2 : forall (x y z : Point) (_ : DiPt x y), or (DiPt x z) (DiPt y z)
H'1 : Irreflexive Point DiPt
H'0 : EqPt b c
H' : DiPt a b
a,b,c : Point
*****
DiPt b c
+++++
trivial.
-----
Theorem cong_eqpt_dipt : forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.
Proof.
intros a b c H' H'0.
elim apart_dipt.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 a b c).

*****
H'2 : forall (x y z : Point) (_ : DiPt x y), or (DiPt x z) (DiPt y z)
H'1 : Irreflexive Point DiPt
H'0 : EqPt b c
H' : DiPt a b
a,b,c : Point
*****
DiPt a b
+++++
trivial.
-----
Theorem cong_eqpt_dipt : forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.
Proof.
intros a b c H' H'0.
elim apart_dipt.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 a b c).

*****

*****

+++++
Qed.
-----
Theorem cong_eqln_diln :\n forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.
-----
Theorem cong_eqln_diln : forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.

*****

*****
forall (l m n : Line) (_ : DiLn l m) (_ : EqLn m n), DiLn l n
+++++
Proof.
-----
Theorem cong_eqln_diln : forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.
Proof.

*****

*****
forall (l m n : Line) (_ : DiLn l m) (_ : EqLn m n), DiLn l n
+++++
intros l m n H' H'0.
-----
Theorem cong_eqln_diln : forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.
Proof.
intros l m n H' H'0.

*****
H'0 : EqLn m n
H' : DiLn l m
l,m,n : Line
*****
DiLn l n
+++++
elim apart_diln.
-----
Theorem cong_eqln_diln : forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.
Proof.
intros l m n H' H'0.
elim apart_diln.

*****
H'0 : EqLn m n
H' : DiLn l m
l,m,n : Line
*****
forall (_ : Irreflexive Line DiLn) (_ : Separating Line DiLn), DiLn l n
+++++
unfold Separating at 1 in |- *.
-----
Theorem cong_eqln_diln : forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.
Proof.
intros l m n H' H'0.
elim apart_diln.
unfold Separating at 1 in |- *.

*****
H'0 : EqLn m n
H' : DiLn l m
l,m,n : Line
*****
forall (_ : Irreflexive Line DiLn) (_ : forall (x y z : Line) (_ : DiLn x y), or (DiLn x z) (DiLn y z)), DiLn l n
+++++
intros H'1 H'2.
-----
Theorem cong_eqln_diln : forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.
Proof.
intros l m n H' H'0.
elim apart_diln.
unfold Separating at 1 in |- *.
intros H'1 H'2.

*****
H'2 : forall (x y z : Line) (_ : DiLn x y), or (DiLn x z) (DiLn y z)
H'1 : Irreflexive Line DiLn
H'0 : EqLn m n
H' : DiLn l m
l,m,n : Line
*****
DiLn l n
+++++
elim (H'2 l m n).
-----
Theorem cong_eqln_diln : forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.
Proof.
intros l m n H' H'0.
elim apart_diln.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).

*****
H'2 : forall (x y z : Line) (_ : DiLn x y), or (DiLn x z) (DiLn y z)
H'1 : Irreflexive Line DiLn
H'0 : EqLn m n
H' : DiLn l m
l,m,n : Line
*****
forall _ : DiLn l n, DiLn l n
+++++
trivial.
-----
Theorem cong_eqln_diln : forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.
Proof.
intros l m n H' H'0.
elim apart_diln.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).

*****
H'2 : forall (x y z : Line) (_ : DiLn x y), or (DiLn x z) (DiLn y z)
H'1 : Irreflexive Line DiLn
H'0 : EqLn m n
H' : DiLn l m
l,m,n : Line
*****
forall _ : DiLn m n, DiLn l n
+++++
trivial.
-----
Theorem cong_eqln_diln : forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.
Proof.
intros l m n H' H'0.
elim apart_diln.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).
trivial.

*****
H'2 : forall (x y z : Line) (_ : DiLn x y), or (DiLn x z) (DiLn y z)
H'1 : Irreflexive Line DiLn
H'0 : EqLn m n
H' : DiLn l m
l,m,n : Line
*****
forall _ : DiLn m n, DiLn l n
+++++
intro H'3.
-----
Theorem cong_eqln_diln : forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.
Proof.
intros l m n H' H'0.
elim apart_diln.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).
trivial.
intro H'3.

*****
H'3 : DiLn m n
H'2 : forall (x y z : Line) (_ : DiLn x y), or (DiLn x z) (DiLn y z)
H'1 : Irreflexive Line DiLn
H'0 : EqLn m n
H' : DiLn l m
l,m,n : Line
*****
DiLn l n
+++++
elim H'0.
-----
Theorem cong_eqln_diln : forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.
Proof.
intros l m n H' H'0.
elim apart_diln.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).
trivial.
intro H'3.
elim H'0.

*****
H'3 : DiLn m n
H'2 : forall (x y z : Line) (_ : DiLn x y), or (DiLn x z) (DiLn y z)
H'1 : Irreflexive Line DiLn
H'0 : EqLn m n
H' : DiLn l m
l,m,n : Line
*****
DiLn m n
+++++
trivial.
-----
Theorem cong_eqln_diln : forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.
Proof.
intros l m n H' H'0.
elim apart_diln.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).

*****
H'2 : forall (x y z : Line) (_ : DiLn x y), or (DiLn x z) (DiLn y z)
H'1 : Irreflexive Line DiLn
H'0 : EqLn m n
H' : DiLn l m
l,m,n : Line
*****
DiLn l m
+++++
trivial.
-----
Theorem cong_eqln_diln : forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.
Proof.
intros l m n H' H'0.
elim apart_diln.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).

*****

*****

+++++
Qed.
-----
Theorem eqln_imp_par : forall l m : Line, EqLn l m -> Par l m.
-----
Theorem eqln_imp_par : forall l m : Line, EqLn l m -> Par l m.

*****

*****
forall (l m : Line) (_ : EqLn l m), Par l m
+++++
Proof.
-----
Theorem eqln_imp_par : forall l m : Line, EqLn l m -> Par l m.
Proof.

*****

*****
forall (l m : Line) (_ : EqLn l m), Par l m
+++++
unfold Par in |- *.
-----
Theorem eqln_imp_par : forall l m : Line, EqLn l m -> Par l m.
Proof.
unfold Par in |- *.

*****

*****
forall (l m : Line) (_ : EqLn l m), Negation Line ConLn l m
+++++
unfold EqLn in |- *.
-----
Theorem eqln_imp_par : forall l m : Line, EqLn l m -> Par l m.
Proof.
unfold Par in |- *.
unfold EqLn in |- *.

*****

*****
forall (l m : Line) (_ : Negation Line DiLn l m), Negation Line ConLn l m
+++++
unfold Negation in |- *.
-----
Theorem eqln_imp_par : forall l m : Line, EqLn l m -> Par l m.
Proof.
unfold Par in |- *.
unfold EqLn in |- *.
unfold Negation in |- *.

*****

*****
forall (l m : Line) (_ : not (DiLn l m)), not (ConLn l m)
+++++
red in |- *.
-----
Theorem eqln_imp_par : forall l m : Line, EqLn l m -> Par l m.
Proof.
unfold Par in |- *.
unfold EqLn in |- *.
unfold Negation in |- *.
red in |- *.

*****

*****
forall (l m : Line) (_ : not (DiLn l m)) (_ : ConLn l m), False
+++++
auto.
-----
Theorem eqln_imp_par : forall l m : Line, EqLn l m -> Par l m.
Proof.
unfold Par in |- *.
unfold EqLn in |- *.
unfold Negation in |- *.
red in |- *.
auto.

*****

*****

+++++
Qed.
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.

*****

*****
forall (l m n : Line) (_ : ConLn l m) (_ : Par m n), ConLn l n
+++++
Proof.
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.
Proof.

*****

*****
forall (l m n : Line) (_ : ConLn l m) (_ : Par m n), ConLn l n
+++++
intros l m n H' H'0.
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.
Proof.
intros l m n H' H'0.

*****
H'0 : Par m n
H' : ConLn l m
l,m,n : Line
*****
ConLn l n
+++++
elim apart_con.
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim apart_con.

*****
H'0 : Par m n
H' : ConLn l m
l,m,n : Line
*****
forall (_ : Irreflexive Line ConLn) (_ : Separating Line ConLn), ConLn l n
+++++
unfold Separating at 1 in |- *.
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim apart_con.
unfold Separating at 1 in |- *.

*****
H'0 : Par m n
H' : ConLn l m
l,m,n : Line
*****
forall (_ : Irreflexive Line ConLn) (_ : forall (x y z : Line) (_ : ConLn x y), or (ConLn x z) (ConLn y z)), ConLn l n
+++++
intros H'1 H'2.
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim apart_con.
unfold Separating at 1 in |- *.
intros H'1 H'2.

*****
H'2 : forall (x y z : Line) (_ : ConLn x y), or (ConLn x z) (ConLn y z)
H'1 : Irreflexive Line ConLn
H'0 : Par m n
H' : ConLn l m
l,m,n : Line
*****
ConLn l n
+++++
elim (H'2 l m n).
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim apart_con.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).

*****
H'2 : forall (x y z : Line) (_ : ConLn x y), or (ConLn x z) (ConLn y z)
H'1 : Irreflexive Line ConLn
H'0 : Par m n
H' : ConLn l m
l,m,n : Line
*****
forall _ : ConLn l n, ConLn l n
+++++
trivial.
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim apart_con.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).

*****
H'2 : forall (x y z : Line) (_ : ConLn x y), or (ConLn x z) (ConLn y z)
H'1 : Irreflexive Line ConLn
H'0 : Par m n
H' : ConLn l m
l,m,n : Line
*****
forall _ : ConLn m n, ConLn l n
+++++
trivial.
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim apart_con.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).
trivial.

*****
H'2 : forall (x y z : Line) (_ : ConLn x y), or (ConLn x z) (ConLn y z)
H'1 : Irreflexive Line ConLn
H'0 : Par m n
H' : ConLn l m
l,m,n : Line
*****
forall _ : ConLn m n, ConLn l n
+++++
intro H'3.
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim apart_con.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).
trivial.
intro H'3.

*****
H'3 : ConLn m n
H'2 : forall (x y z : Line) (_ : ConLn x y), or (ConLn x z) (ConLn y z)
H'1 : Irreflexive Line ConLn
H'0 : Par m n
H' : ConLn l m
l,m,n : Line
*****
ConLn l n
+++++
elim H'0.
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim apart_con.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).
trivial.
intro H'3.
elim H'0.

*****
H'3 : ConLn m n
H'2 : forall (x y z : Line) (_ : ConLn x y), or (ConLn x z) (ConLn y z)
H'1 : Irreflexive Line ConLn
H'0 : Par m n
H' : ConLn l m
l,m,n : Line
*****
ConLn m n
+++++
trivial.
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim apart_con.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).

*****
H'2 : forall (x y z : Line) (_ : ConLn x y), or (ConLn x z) (ConLn y z)
H'1 : Irreflexive Line ConLn
H'0 : Par m n
H' : ConLn l m
l,m,n : Line
*****
ConLn l m
+++++
trivial.
-----
Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.
Proof.
intros l m n H' H'0.
elim apart_con.
unfold Separating at 1 in |- *.
intros H'1 H'2.
elim (H'2 l m n).

*****

*****

+++++
Qed.
-----
Theorem sym_SPar : forall x y : Line, SPar x y -> SPar y x.
-----
Theorem sym_SPar : forall x y : Line, SPar x y -> SPar y x.

*****

*****
forall (x y : Line) (_ : SPar x y), SPar y x
+++++
Proof.
-----
Theorem sym_SPar : forall x y : Line, SPar x y -> SPar y x.
Proof.

*****

*****
forall (x y : Line) (_ : SPar x y), SPar y x
+++++
unfold SPar in |- *.
-----
Theorem sym_SPar : forall x y : Line, SPar x y -> SPar y x.
Proof.
unfold SPar in |- *.

*****

*****
forall (x y : Line) (_ : and (Par x y) (DiLn x y)), and (Par y x) (DiLn y x)
+++++
intuition.
-----
Theorem sym_SPar : forall x y : Line, SPar x y -> SPar y x.
Proof.
unfold SPar in |- *.
intuition.

*****

*****

+++++
Qed.
-----
Hint Resolve sym_SPar.
-----
Theorem cong_eqln_spar :\n forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.

*****

*****
forall (l m n : Line) (_ : SPar l m) (_ : EqLn m n), SPar l n
+++++
Proof.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.

*****

*****
forall (l m n : Line) (_ : SPar l m) (_ : EqLn m n), SPar l n
+++++
unfold SPar in |- *.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.

*****

*****
forall (l m n : Line) (_ : and (Par l m) (DiLn l m)) (_ : EqLn m n), and (Par l n) (DiLn l n)
+++++
intros l m n H'.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.
intros l m n H'.

*****
H' : and (Par l m) (DiLn l m)
l,m,n : Line
*****
forall _ : EqLn m n, and (Par l n) (DiLn l n)
+++++
elim H'.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.
intros l m n H'.
elim H'.

*****
H' : and (Par l m) (DiLn l m)
l,m,n : Line
*****
forall (_ : Par l m) (_ : DiLn l m) (_ : EqLn m n), and (Par l n) (DiLn l n)
+++++
intros H'0 H'1.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.
intros l m n H'.
elim H'.
intros H'0 H'1.

*****
H'1 : DiLn l m
H'0 : Par l m
H' : and (Par l m) (DiLn l m)
l,m,n : Line
*****
forall _ : EqLn m n, and (Par l n) (DiLn l n)
+++++
try exact H'0.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.
intros l m n H'.
elim H'.
intros H'0 H'1.
try exact H'0.

*****
H'1 : DiLn l m
H'0 : Par l m
H' : and (Par l m) (DiLn l m)
l,m,n : Line
*****
forall _ : EqLn m n, and (Par l n) (DiLn l n)
+++++
clear H'.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.
intros l m n H'.
elim H'.
intros H'0 H'1.
try exact H'0.
clear H'.

*****
H'1 : DiLn l m
H'0 : Par l m
l,m,n : Line
*****
forall _ : EqLn m n, and (Par l n) (DiLn l n)
+++++
intro H'.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.
intros l m n H'.
elim H'.
intros H'0 H'1.
try exact H'0.
clear H'.
intro H'.

*****
H' : EqLn m n
H'1 : DiLn l m
H'0 : Par l m
l,m,n : Line
*****
and (Par l n) (DiLn l n)
+++++
split.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.
intros l m n H'.
elim H'.
intros H'0 H'1.
try exact H'0.
clear H'.
intro H'.
split.

*****
H' : EqLn m n
H'1 : DiLn l m
H'0 : Par l m
l,m,n : Line
*****
Par l n
+++++
apply cong_eqln_par with (m := m).
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.
intros l m n H'.
elim H'.
intros H'0 H'1.
try exact H'0.
clear H'.
intro H'.
split.
apply cong_eqln_par with (m := m).

*****
H' : EqLn m n
H'1 : DiLn l m
H'0 : Par l m
l,m,n : Line
*****
Par l m
+++++
trivial.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.
intros l m n H'.
elim H'.
intros H'0 H'1.
try exact H'0.
clear H'.
intro H'.
split.
apply cong_eqln_par with (m := m).

*****
H' : EqLn m n
H'1 : DiLn l m
H'0 : Par l m
l,m,n : Line
*****
EqLn m n
+++++
trivial.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.
intros l m n H'.
elim H'.
intros H'0 H'1.
try exact H'0.
clear H'.
intro H'.
split.

*****
H' : EqLn m n
H'1 : DiLn l m
H'0 : Par l m
l,m,n : Line
*****
DiLn l n
+++++
apply cong_eqln_diln with (m := m).
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.
intros l m n H'.
elim H'.
intros H'0 H'1.
try exact H'0.
clear H'.
intro H'.
split.
apply cong_eqln_diln with (m := m).

*****
H' : EqLn m n
H'1 : DiLn l m
H'0 : Par l m
l,m,n : Line
*****
DiLn l m
+++++
trivial.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.
intros l m n H'.
elim H'.
intros H'0 H'1.
try exact H'0.
clear H'.
intro H'.
split.
apply cong_eqln_diln with (m := m).

*****
H' : EqLn m n
H'1 : DiLn l m
H'0 : Par l m
l,m,n : Line
*****
EqLn m n
+++++
trivial.
-----
Theorem cong_eqln_spar : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.
Proof.
unfold SPar in |- *.
intros l m n H'.
elim H'.
intros H'0 H'1.
try exact H'0.
clear H'.
intro H'.
split.

*****

*****

+++++
Qed.
-----
Definition reverse : Segment -> Segment.
-----
Definition reverse : Segment -> Segment.

*****

*****
forall _ : Segment, Segment
+++++
Proof.
-----
Definition reverse : Segment -> Segment.
Proof.

*****

*****
forall _ : Segment, Segment
+++++
intro H'.
-----
Definition reverse : Segment -> Segment.
Proof.
intro H'.

*****
H' : Segment
*****
Segment
+++++
elim H'.
-----
Definition reverse : Segment -> Segment.
Proof.
intro H'.
elim H'.

*****
H' : Segment
*****
forall (origin extremity : Point) (_ : DiPt origin extremity), Segment
+++++
intros a b H'0.
-----
Definition reverse : Segment -> Segment.
Proof.
intro H'.
elim H'.
intros a b H'0.

*****
H'0 : DiPt a b
a,b : Point
H' : Segment
*****
Segment
+++++
apply (Seg b a).
-----
Definition reverse : Segment -> Segment.
Proof.
intro H'.
elim H'.
intros a b H'0.
apply (Seg b a).

*****
H'0 : DiPt a b
a,b : Point
H' : Segment
*****
DiPt b a
+++++
auto.
-----
Definition reverse : Segment -> Segment.
Proof.
intro H'.
elim H'.
intros a b H'0.
apply (Seg b a).
auto.

*****

*****

+++++
Defined.
-----
Theorem orig_rev : forall x : Segment, origin x = extremity (reverse x).
-----
Theorem orig_rev : forall x : Segment, origin x = extremity (reverse x).

*****

*****
forall x : Segment, eq (origin x) (extremity (reverse x))
+++++
Proof.
-----
Theorem orig_rev : forall x : Segment, origin x = extremity (reverse x).
Proof.

*****

*****
forall x : Segment, eq (origin x) (extremity (reverse x))
+++++
intro x.
-----
Theorem orig_rev : forall x : Segment, origin x = extremity (reverse x).
Proof.
intro x.

*****
x : Segment
*****
eq (origin x) (extremity (reverse x))
+++++
elim x.
-----
Theorem orig_rev : forall x : Segment, origin x = extremity (reverse x).
Proof.
intro x.
elim x.

*****
x : Segment
*****
forall (origin0 extremity0 : Point) (Seg_cond : DiPt origin0 extremity0), eq (origin {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |}) (extremity (reverse {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |}))
+++++
simpl in |- *.
-----
Theorem orig_rev : forall x : Segment, origin x = extremity (reverse x).
Proof.
intro x.
elim x.
simpl in |- *.

*****
x : Segment
*****
forall (origin extremity : Point) (_ : DiPt origin extremity), eq origin origin
+++++
auto.
-----
Theorem orig_rev : forall x : Segment, origin x = extremity (reverse x).
Proof.
intro x.
elim x.
simpl in |- *.
auto.

*****

*****

+++++
Qed.
-----
Theorem ext_rev : forall x : Segment, extremity x = origin (reverse x).
-----
Theorem ext_rev : forall x : Segment, extremity x = origin (reverse x).

*****

*****
forall x : Segment, eq (extremity x) (origin (reverse x))
+++++
Proof.
-----
Theorem ext_rev : forall x : Segment, extremity x = origin (reverse x).
Proof.

*****

*****
forall x : Segment, eq (extremity x) (origin (reverse x))
+++++
intro x.
-----
Theorem ext_rev : forall x : Segment, extremity x = origin (reverse x).
Proof.
intro x.

*****
x : Segment
*****
eq (extremity x) (origin (reverse x))
+++++
elim x.
-----
Theorem ext_rev : forall x : Segment, extremity x = origin (reverse x).
Proof.
intro x.
elim x.

*****
x : Segment
*****
forall (origin0 extremity0 : Point) (Seg_cond : DiPt origin0 extremity0), eq (extremity {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |}) (origin (reverse {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |}))
+++++
simpl in |- *.
-----
Theorem ext_rev : forall x : Segment, extremity x = origin (reverse x).
Proof.
intro x.
elim x.
simpl in |- *.

*****
x : Segment
*****
forall (origin extremity : Point) (_ : DiPt origin extremity), eq extremity extremity
+++++
auto.
-----
Theorem ext_rev : forall x : Segment, extremity x = origin (reverse x).
Proof.
intro x.
elim x.
simpl in |- *.
auto.

*****

*****

+++++
Qed.
-----
Theorem rev_defines_sameln : forall x : Segment, EqLn (ln x) (ln (reverse x)).
-----
Theorem rev_defines_sameln : forall x : Segment, EqLn (ln x) (ln (reverse x)).

*****

*****
forall x : Segment, EqLn (ln x) (ln (reverse x))
+++++
Proof.
-----
Theorem rev_defines_sameln : forall x : Segment, EqLn (ln x) (ln (reverse x)).
Proof.

*****

*****
forall x : Segment, EqLn (ln x) (ln (reverse x))
+++++
intro x.
-----
Theorem rev_defines_sameln : forall x : Segment, EqLn (ln x) (ln (reverse x)).
Proof.
intro x.

*****
x : Segment
*****
EqLn (ln x) (ln (reverse x))
+++++
apply Uniqueness_of_constructed_lines.
-----
Theorem rev_defines_sameln : forall x : Segment, EqLn (ln x) (ln (reverse x)).
Proof.
intro x.
apply Uniqueness_of_constructed_lines.

*****
x : Segment
*****
Incident (origin (reverse x)) (ln x)
+++++
rewrite <- (ext_rev x).
-----
Theorem rev_defines_sameln : forall x : Segment, EqLn (ln x) (ln (reverse x)).
Proof.
intro x.
apply Uniqueness_of_constructed_lines.
rewrite <- (ext_rev x).

*****
x : Segment
*****
Incident (extremity x) (ln x)
+++++
auto.
-----
Theorem rev_defines_sameln : forall x : Segment, EqLn (ln x) (ln (reverse x)).
Proof.
intro x.
apply Uniqueness_of_constructed_lines.

*****
x : Segment
*****
Incident (extremity (reverse x)) (ln x)
+++++
rewrite <- (orig_rev x).
-----
Theorem rev_defines_sameln : forall x : Segment, EqLn (ln x) (ln (reverse x)).
Proof.
intro x.
apply Uniqueness_of_constructed_lines.
rewrite <- (orig_rev x).

*****
x : Segment
*****
Incident (origin x) (ln x)
+++++
auto.
-----
Theorem rev_defines_sameln : forall x : Segment, EqLn (ln x) (ln (reverse x)).
Proof.
intro x.
apply Uniqueness_of_constructed_lines.

*****

*****

+++++
Qed.
-----
Hint Resolve rev_defines_sameln.
-----
Definition flip : Twolines -> Twolines.
-----
Definition flip : Twolines -> Twolines.

*****

*****
forall _ : Twolines, Twolines
+++++
Proof.
-----
Definition flip : Twolines -> Twolines.
Proof.

*****

*****
forall _ : Twolines, Twolines
+++++
intro H'.
-----
Definition flip : Twolines -> Twolines.
Proof.
intro H'.

*****
H' : Twolines
*****
Twolines
+++++
elim H'.
-----
Definition flip : Twolines -> Twolines.
Proof.
intro H'.
elim H'.

*****
H' : Twolines
*****
forall (line1 line2 : Line) (_ : ConLn line1 line2), Twolines
+++++
intros l m H'0.
-----
Definition flip : Twolines -> Twolines.
Proof.
intro H'.
elim H'.
intros l m H'0.

*****
H'0 : ConLn l m
l,m : Line
H' : Twolines
*****
Twolines
+++++
apply (Twol m l).
-----
Definition flip : Twolines -> Twolines.
Proof.
intro H'.
elim H'.
intros l m H'0.
apply (Twol m l).

*****
H'0 : ConLn l m
l,m : Line
H' : Twolines
*****
ConLn m l
+++++
auto.
-----
Definition flip : Twolines -> Twolines.
Proof.
intro H'.
elim H'.
intros l m H'0.
apply (Twol m l).
auto.

*****

*****

+++++
Defined.
-----
Theorem line1_flip : forall x : Twolines, line1 x = line2 (flip x).
-----
Theorem line1_flip : forall x : Twolines, line1 x = line2 (flip x).

*****

*****
forall x : Twolines, eq (line1 x) (line2 (flip x))
+++++
Proof.
-----
Theorem line1_flip : forall x : Twolines, line1 x = line2 (flip x).
Proof.

*****

*****
forall x : Twolines, eq (line1 x) (line2 (flip x))
+++++
intro x.
-----
Theorem line1_flip : forall x : Twolines, line1 x = line2 (flip x).
Proof.
intro x.

*****
x : Twolines
*****
eq (line1 x) (line2 (flip x))
+++++
elim x.
-----
Theorem line1_flip : forall x : Twolines, line1 x = line2 (flip x).
Proof.
intro x.
elim x.

*****
x : Twolines
*****
forall (line3 line4 : Line) (Twol_cond : ConLn line3 line4), eq (line1 {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |}) (line2 (flip {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |}))
+++++
simpl in |- *.
-----
Theorem line1_flip : forall x : Twolines, line1 x = line2 (flip x).
Proof.
intro x.
elim x.
simpl in |- *.

*****
x : Twolines
*****
forall (line1 line2 : Line) (_ : ConLn line1 line2), eq line1 line1
+++++
auto.
-----
Theorem line1_flip : forall x : Twolines, line1 x = line2 (flip x).
Proof.
intro x.
elim x.
simpl in |- *.
auto.

*****

*****

+++++
Qed.
-----
Theorem line2_flip : forall x : Twolines, line2 x = line1 (flip x).
-----
Theorem line2_flip : forall x : Twolines, line2 x = line1 (flip x).

*****

*****
forall x : Twolines, eq (line2 x) (line1 (flip x))
+++++
Proof.
-----
Theorem line2_flip : forall x : Twolines, line2 x = line1 (flip x).
Proof.

*****

*****
forall x : Twolines, eq (line2 x) (line1 (flip x))
+++++
intro x.
-----
Theorem line2_flip : forall x : Twolines, line2 x = line1 (flip x).
Proof.
intro x.

*****
x : Twolines
*****
eq (line2 x) (line1 (flip x))
+++++
elim x.
-----
Theorem line2_flip : forall x : Twolines, line2 x = line1 (flip x).
Proof.
intro x.
elim x.

*****
x : Twolines
*****
forall (line3 line4 : Line) (Twol_cond : ConLn line3 line4), eq (line2 {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |}) (line1 (flip {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |}))
+++++
simpl in |- *.
-----
Theorem line2_flip : forall x : Twolines, line2 x = line1 (flip x).
Proof.
intro x.
elim x.
simpl in |- *.

*****
x : Twolines
*****
forall (line1 line2 : Line) (_ : ConLn line1 line2), eq line2 line2
+++++
auto.
-----
Theorem line2_flip : forall x : Twolines, line2 x = line1 (flip x).
Proof.
intro x.
elim x.
simpl in |- *.
auto.

*****

*****

+++++
Qed.
-----
Theorem flip_defines_samept : forall x : Twolines, EqPt (pt x) (pt (flip x)).
-----
Theorem flip_defines_samept : forall x : Twolines, EqPt (pt x) (pt (flip x)).

*****

*****
forall x : Twolines, EqPt (pt x) (pt (flip x))
+++++
Proof.
-----
Theorem flip_defines_samept : forall x : Twolines, EqPt (pt x) (pt (flip x)).
Proof.

*****

*****
forall x : Twolines, EqPt (pt x) (pt (flip x))
+++++
intro x.
-----
Theorem flip_defines_samept : forall x : Twolines, EqPt (pt x) (pt (flip x)).
Proof.
intro x.

*****
x : Twolines
*****
EqPt (pt x) (pt (flip x))
+++++
apply Uniqueness_of_constructed_points.
-----
Theorem flip_defines_samept : forall x : Twolines, EqPt (pt x) (pt (flip x)).
Proof.
intro x.
apply Uniqueness_of_constructed_points.

*****
x : Twolines
*****
Incident (pt x) (line1 (flip x))
+++++
rewrite <- (line2_flip x).
-----
Theorem flip_defines_samept : forall x : Twolines, EqPt (pt x) (pt (flip x)).
Proof.
intro x.
apply Uniqueness_of_constructed_points.
rewrite <- (line2_flip x).

*****
x : Twolines
*****
Incident (pt x) (line2 x)
+++++
auto.
-----
Theorem flip_defines_samept : forall x : Twolines, EqPt (pt x) (pt (flip x)).
Proof.
intro x.
apply Uniqueness_of_constructed_points.

*****
x : Twolines
*****
Incident (pt x) (line2 (flip x))
+++++
rewrite <- (line1_flip x).
-----
Theorem flip_defines_samept : forall x : Twolines, EqPt (pt x) (pt (flip x)).
Proof.
intro x.
apply Uniqueness_of_constructed_points.
rewrite <- (line1_flip x).

*****
x : Twolines
*****
Incident (pt x) (line1 x)
+++++
auto.
-----
Theorem flip_defines_samept : forall x : Twolines, EqPt (pt x) (pt (flip x)).
Proof.
intro x.
apply Uniqueness_of_constructed_points.

*****

*****

+++++
Qed.
-----
Hint Resolve rev_defines_sameln flip_defines_samept.
-----
Definition colinear (x y : Segment) : Prop := EqLn (ln x) (ln y).
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.

*****

*****
Equivalence Segment colinear
+++++
Proof.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.

*****

*****
Equivalence Segment colinear
+++++
cut (Equivalence Line EqLn).
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).

*****

*****
forall _ : Equivalence Line EqLn, Equivalence Segment colinear
+++++
auto.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.

*****

*****
forall _ : Equivalence Line EqLn, Equivalence Segment colinear
+++++
intro H'.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.

*****
H' : Equivalence Line EqLn
*****
Equivalence Segment colinear
+++++
elim H'.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.

*****
H' : Equivalence Line EqLn
*****
forall (_ : Reflexive Line EqLn) (_ : Symmetric Line EqLn) (_ : Transitive Line EqLn), Equivalence Segment colinear
+++++
intros H'0 H'1 H'2.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.
intros H'0 H'1 H'2.

*****
H'2 : Transitive Line EqLn
H'1 : Symmetric Line EqLn
H'0 : Reflexive Line EqLn
H' : Equivalence Line EqLn
*****
Equivalence Segment colinear
+++++
apply Definition_of_equivalence.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.
intros H'0 H'1 H'2.
apply Definition_of_equivalence.

*****
H'2 : Transitive Line EqLn
H'1 : Symmetric Line EqLn
H'0 : Reflexive Line EqLn
H' : Equivalence Line EqLn
*****
Reflexive Segment colinear
+++++
unfold colinear in |- *.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.
intros H'0 H'1 H'2.
apply Definition_of_equivalence.
unfold colinear in |- *.

*****
H'2 : Transitive Line EqLn
H'1 : Symmetric Line EqLn
H'0 : Reflexive Line EqLn
H' : Equivalence Line EqLn
*****
Reflexive Segment (fun x y : Segment => EqLn (ln x) (ln y))
+++++
auto.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.
intros H'0 H'1 H'2.
apply Definition_of_equivalence.

*****
H'2 : Transitive Line EqLn
H'1 : Symmetric Line EqLn
H'0 : Reflexive Line EqLn
H' : Equivalence Line EqLn
*****
Symmetric Segment colinear
+++++
unfold colinear in |- *.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.
intros H'0 H'1 H'2.
apply Definition_of_equivalence.
unfold colinear in |- *.

*****
H'2 : Transitive Line EqLn
H'1 : Symmetric Line EqLn
H'0 : Reflexive Line EqLn
H' : Equivalence Line EqLn
*****
Symmetric Segment (fun x y : Segment => EqLn (ln x) (ln y))
+++++
auto.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.
intros H'0 H'1 H'2.
apply Definition_of_equivalence.

*****
H'2 : Transitive Line EqLn
H'1 : Symmetric Line EqLn
H'0 : Reflexive Line EqLn
H' : Equivalence Line EqLn
*****
Transitive Segment colinear
+++++
unfold colinear in |- *.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.
intros H'0 H'1 H'2.
apply Definition_of_equivalence.
unfold colinear in |- *.

*****
H'2 : Transitive Line EqLn
H'1 : Symmetric Line EqLn
H'0 : Reflexive Line EqLn
H' : Equivalence Line EqLn
*****
Transitive Segment (fun x y : Segment => EqLn (ln x) (ln y))
+++++
auto.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.
intros H'0 H'1 H'2.
apply Definition_of_equivalence.
unfold colinear in |- *.
auto.

*****
H'2 : Transitive Line EqLn
H'1 : Symmetric Line EqLn
H'0 : Reflexive Line EqLn
H' : Equivalence Line EqLn
*****
Transitive Segment (fun x y : Segment => EqLn (ln x) (ln y))
+++++
red in |- *.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.
intros H'0 H'1 H'2.
apply Definition_of_equivalence.
unfold colinear in |- *.
auto.
red in |- *.

*****
H'2 : Transitive Line EqLn
H'1 : Symmetric Line EqLn
H'0 : Reflexive Line EqLn
H' : Equivalence Line EqLn
*****
forall (x y z : Segment) (_ : EqLn (ln x) (ln y)) (_ : EqLn (ln y) (ln z)), EqLn (ln x) (ln z)
+++++
intros x y z H'3 H'4.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.
intros H'0 H'1 H'2.
apply Definition_of_equivalence.
unfold colinear in |- *.
auto.
red in |- *.
intros x y z H'3 H'4.

*****
H'4 : EqLn (ln y) (ln z)
H'3 : EqLn (ln x) (ln y)
x,y,z : Segment
H'2 : Transitive Line EqLn
H'1 : Symmetric Line EqLn
H'0 : Reflexive Line EqLn
H' : Equivalence Line EqLn
*****
EqLn (ln x) (ln z)
+++++
red in H'2.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.
intros H'0 H'1 H'2.
apply Definition_of_equivalence.
unfold colinear in |- *.
auto.
red in |- *.
intros x y z H'3 H'4.
red in H'2.

*****
H'4 : EqLn (ln y) (ln z)
H'3 : EqLn (ln x) (ln y)
x,y,z : Segment
H'2 : forall (x y z : Line) (_ : EqLn x y) (_ : EqLn y z), EqLn x z
H'1 : Symmetric Line EqLn
H'0 : Reflexive Line EqLn
H' : Equivalence Line EqLn
*****
EqLn (ln x) (ln z)
+++++
apply H'2 with (y := ln y).
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.
intros H'0 H'1 H'2.
apply Definition_of_equivalence.
unfold colinear in |- *.
auto.
red in |- *.
intros x y z H'3 H'4.
red in H'2.
apply H'2 with (y := ln y).

*****
H'4 : EqLn (ln y) (ln z)
H'3 : EqLn (ln x) (ln y)
x,y,z : Segment
H'2 : forall (x y z : Line) (_ : EqLn x y) (_ : EqLn y z), EqLn x z
H'1 : Symmetric Line EqLn
H'0 : Reflexive Line EqLn
H' : Equivalence Line EqLn
*****
EqLn (ln x) (ln y)
+++++
auto.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).
auto.
intro H'.
elim H'.
intros H'0 H'1 H'2.
apply Definition_of_equivalence.
unfold colinear in |- *.
auto.
red in |- *.
intros x y z H'3 H'4.
red in H'2.
apply H'2 with (y := ln y).

*****
H'4 : EqLn (ln y) (ln z)
H'3 : EqLn (ln x) (ln y)
x,y,z : Segment
H'2 : forall (x y z : Line) (_ : EqLn x y) (_ : EqLn y z), EqLn x z
H'1 : Symmetric Line EqLn
H'0 : Reflexive Line EqLn
H' : Equivalence Line EqLn
*****
EqLn (ln y) (ln z)
+++++
auto.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).

*****

*****
Equivalence Line EqLn
+++++
auto.
-----
Theorem Colinearity_is_equivalence : Equivalence Segment colinear.
Proof.
cut (Equivalence Line EqLn).

*****

*****

+++++
Qed.
-----
